<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>코딩새내기 일상일지</title>
    <description>github blog</description>
    <link>http://munjeongkang.github.io/</link>
    <atom:link href="http://munjeongkang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 08 Apr 2020 10:44:28 +0900</pubDate>
    <lastBuildDate>Wed, 08 Apr 2020 10:44:28 +0900</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Agent Based Modeling - Emergence</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Emergence&lt;/b&gt;는 ABM의 가장 중요하고 독특한 특징으로 
&lt;ol&gt;
&lt;li&gt;시스템 이해하기 (시스템에 관한 사전지식 등)&lt;/li&gt;
&lt;li&gt;목표를 분명히 하기&lt;/li&gt;
&lt;li&gt;모델에 대한 묘사 공식화하기&lt;/li&gt;
&lt;li&gt;모델링 소프트웨어로 변환하기&lt;/li&gt;
&lt;li&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;프로그램 확인하기(verify, debugging)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;모델 확인하기(vaildate)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;실험 디자인하기&lt;/li&gt;
&lt;li&gt;모델 실행하기&lt;/li&gt;
&lt;li&gt;결과에 대해 insight를 얻고 분석하여 문서화하기&lt;/li&gt;
&lt;/ol&gt;

모델을 테스트하는 3단계는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Vaildation&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Verification&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Debugging&lt;/b&gt;이다. Verification은 모델 formulation이 소프트웨어에서 정확하게 실행되는지 확인하는 것이다. 즉, 원하는대로 프로그램이 실행되는지 확실히 하는 것이다. 이 과정에서 실수를 찾고 고치는 노력이 요구되며 모델링의 효율을 높이기 위해 가능한 빨리 테스트를 시작하고 코드를 지속적으로 테스트해야한다. (디버깅도 verification의 한 부분이다.) Vaildation은 모델이 실제 상황을 충분히 잘 반영하고 있는지 확인하는 것이다. ABM에서는 특히 예측되지 않은 결과(Unexpected Result)에 대한 주의가 필요하다. 결과가 새롭고(novel) 중요한지, 모델 디자인은 의심스럽지 않은지, 프로그래밍 실수가 있는지 등을 확인해야한다.  
&lt;br /&gt; &lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-right: 1em;&quot;&gt;
Common Kinds of Errors
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
흔히 발생하는 에러들은 다음과 같다. 
&lt;br /&gt;&lt;br /&gt;
&lt;li type=&quot;circle&quot;&gt;Typographical Errors (타이핑을 잘못한 경우)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Syntax Errors (잘못된 구문)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;isunderstanding Primitives (원래 생각했던대로 정확하게 구현을 못한 경우)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Wrong Display Setting&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Run-Time Errors (프로그램을 실행할 때, 컴퓨터가 다룰 수 없는 무언가가 있는 경우)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt; &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Logic Errors&lt;/b&gt; (잘못된 식, 부정확한 조건 등)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Formulation Errors (가정, 알고리즘, 파라미터 값에 대한 에러, validation issues)&lt;/li&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-right: 1em;&quot;&gt;
Techniques for Debugging and Testing
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
실수를 줄이기 위해서는 Debugging과 Testing 과정이 중요하며 다음과 같은 기법들이 있다.
&lt;br /&gt;&lt;br /&gt;

&lt;li type=&quot;circle&quot;&gt; Syntax Checking (코드 작성시 수시로 syntax를 확인하는 습관을 가지는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Visual Testing (시각적으로 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Print Statement (어떻게 작동하는지 프린트해서 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Spot Tests with Agent Monitors (NetLogo View에 있는 Agent Monitor로 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Stress Tests (extreme 값을 파라미터나 input으로 넣어 프로그램을 실행하는 것, 평범한 조건에서 숨겨진 에러를 발견할 수도 있다.), 
&lt;li type=&quot;circle&quot;&gt;Test Procedure (중간 output을 만들어 테스트 해보는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Test Programs (특정한 프로그램 아이디어를 테스트하기 위해 짧은 프로그램으로 분리하여 실행하는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Code Reviews (동료들과 리뷰해보는 것, 다른 사람이 확인하면 실수가 발견될 수 있고 코드를 잘 정리하고 이해하기 쉽게 하기위해서)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Statistical Analysis of File OutPut (예상했던대로 모델이 formulation 되었는지 확인하기 위해 모델의 핵심 부분을 file output으로 적어 분석해보는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Independent Reimplementation of Submodels (엑셀이나 R, Python 등 다른 플랫폼으로 확인해보는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Documentation of Tests(사용된 test의 종류, 모델을 실행한 방법과 결과 등을 문서화하는 것)&lt;/li&gt;

&lt;br /&gt;

&lt;/li&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM8/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM8/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Testing Your Program</title>
        <description>&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
Overview of a Simulation Study
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;ol&gt;
&lt;li&gt;시스템 이해하기 (시스템에 관한 사전지식 등)&lt;/li&gt;
&lt;li&gt;목표를 분명히 하기&lt;/li&gt;
&lt;li&gt;모델에 대한 묘사 공식화하기&lt;/li&gt;
&lt;li&gt;모델링 소프트웨어로 변환하기&lt;/li&gt;
&lt;li&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;프로그램 확인하기(verify, debugging)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;모델 확인하기(vaildate)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;실험 디자인하기&lt;/li&gt;
&lt;li&gt;모델 실행하기&lt;/li&gt;
&lt;li&gt;결과에 대해 insight를 얻고 분석하여 문서화하기&lt;/li&gt;
&lt;/ol&gt;

모델을 테스트하는 3단계는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Vaildation&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Verification&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Debugging&lt;/b&gt;이다. Verification은 모델 formulation이 소프트웨어에서 정확하게 실행되는지 확인하는 것이다. 즉, 원하는대로 프로그램이 실행되는지 확실히 하는 것이다. 이 과정에서 실수를 찾고 고치는 노력이 요구되며 모델링의 효율을 높이기 위해 가능한 빨리 테스트를 시작하고 코드를 지속적으로 테스트해야한다. (디버깅도 verification의 한 부분이다.) Vaildation은 모델이 실제 상황을 충분히 잘 반영하고 있는지 확인하는 것이다. ABM에서는 특히 예측되지 않은 결과(Unexpected Result)에 대한 주의가 필요하다. 결과가 새롭고(novel) 중요한지, 모델 디자인은 의심스럽지 않은지, 프로그래밍 실수가 있는지 등을 확인해야한다.  
&lt;br /&gt; &lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-right: 1em;&quot;&gt;
Common Kinds of Errors
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
흔히 발생하는 에러들은 다음과 같다. 
&lt;br /&gt;&lt;br /&gt;
&lt;li type=&quot;circle&quot;&gt;Typographical Errors (타이핑을 잘못한 경우)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Syntax Errors (잘못된 구문)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;isunderstanding Primitives (원래 생각했던대로 정확하게 구현을 못한 경우)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Wrong Display Setting&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Run-Time Errors (프로그램을 실행할 때, 컴퓨터가 다룰 수 없는 무언가가 있는 경우)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt; &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Logic Errors&lt;/b&gt; (잘못된 식, 부정확한 조건 등)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Formulation Errors (가정, 알고리즘, 파라미터 값에 대한 에러, validation issues)&lt;/li&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-right: 1em;&quot;&gt;
Techniques for Debugging and Testing
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
실수를 줄이기 위해서는 Debugging과 Testing 과정이 중요하며 다음과 같은 기법들이 있다.
&lt;br /&gt;&lt;br /&gt;

&lt;li type=&quot;circle&quot;&gt; Syntax Checking (코드 작성시 수시로 syntax를 확인하는 습관을 가지는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Visual Testing (시각적으로 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Print Statement (어떻게 작동하는지 프린트해서 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Spot Tests with Agent Monitors (NetLogo View에 있는 Agent Monitor로 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Stress Tests (extreme 값을 파라미터나 input으로 넣어 프로그램을 실행하는 것, 평범한 조건에서 숨겨진 에러를 발견할 수도 있다.), 
&lt;li type=&quot;circle&quot;&gt;Test Procedure (중간 output을 만들어 테스트 해보는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Test Programs (특정한 프로그램 아이디어를 테스트하기 위해 짧은 프로그램으로 분리하여 실행하는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Code Reviews (동료들과 리뷰해보는 것, 다른 사람이 확인하면 실수가 발견될 수 있고 코드를 잘 정리하고 이해하기 쉽게 하기위해서)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Statistical Analysis of File OutPut (예상했던대로 모델이 formulation 되었는지 확인하기 위해 모델의 핵심 부분을 file output으로 적어 분석해보는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Independent Reimplementation of Submodels (엑셀이나 R, Python 등 다른 플랫폼으로 확인해보는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Documentation of Tests(사용된 test의 종류, 모델을 실행한 방법과 결과 등을 문서화하는 것)&lt;/li&gt;

&lt;br /&gt;

&lt;/li&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM7/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM7/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - From Animations to Science</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
모델은 그 자체가 목적은 아니다. 관찰된 사실이나 증명된 이론을 사용하여 실제 실험이나 가상의 실험을 수행할 수 있도록 돕는 역할을 한다. 일반적으로 과학적 접근방법의 프로세스는 다음과 같다. 먼저 경험적 연구(Observation/Measurement 등)와 이론적 연구(Ideas/Abstract Principles 등)를 토대로 가설을 세우고 가설을 테스트한다. 만약 가설이 틀렸다면 다시 가설을 세우고 맞을경우 가설을 증명하여 일반적인 법칙으로 받아들인다.
&lt;br /&gt; &lt;br /&gt;
앞서 살펴본 Butterfly model의 경우 나비의 움직임을 시뮬레이션 해볼 수는 있지만, corridors가 언제 어떻게 강하게 발현되는지에 대해서는 설명해주지 않는다. 이 경우 &#39;corridor를 어떻게 묘사해야할까&#39; 라는 의문이 든다. 그렇기 때문에 우리는 분석을 위한 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Quantitative Output&lt;/b&gt;이 필요하다. 파라미터 &lt;i&gt;q&lt;/i&gt; (나비가 가장 높은 위치로 이동할 확률)를 바꾸거나 지형을 바꿈으로써 나비가 움직인 경로의 길이가 어떻게 변화하는지 수량화하는 것도 하나의 방법이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly4.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly3.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;
파라미터 &lt;i&gt;q&lt;/i&gt;에 따라 corridor width가 변하는 것을 볼 수 있다. &lt;i&gt;q&lt;/i&gt;가 1에 가까울수록 나비들의 이동에 대한 무작위성이 적기 때문에 움직임이 직선에 가까워지고 corridor width가 더 작아짐을 볼 수 있다. NetLogo의 plot을 활용하여 시간에 따른 corridor의 변화를 그려볼 수도 있다. 이러한 분석을 Time-series 분석이라고 한다. 

&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM6/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM6/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Butterfly Hilltopping Model</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
모델 설명
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
이번에는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Butterfly Hilltopping Model&lt;/b&gt;의 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;ODD&lt;/b&gt;를 설명하고자 한다. 일단 ODD란 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;O&lt;/b&gt;verview, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;D&lt;/b&gt;esign Concepts, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;D&lt;/b&gt;etails의 약어이다. Overview는 이 모델이 무엇인지, 어떻게 디자인 되었는지 설명한다. (Purpose, Entities, State Variables, Scales, Process Overview, Scheduling 등) Design Concepts는 ABM의 필수적인 특징을 묘사하고 디자인 컨셉을 설명한다. Details는 완전한 묘사를 위해 필요한 세부 사항을 포함한다. (Initialization, Input Data, Submodels 등)
&lt;br /&gt;&lt;br /&gt;
많은 동물들이 여러 목적(mating 등)을 위해 home location을 떠나 다른 곳으로 이동한다. 특히 나비들은 landscape에 반응하여 움직이는데 이러한 움직임을 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Corridors&lt;/b&gt; 라고 불리는 경로로 연결시킬 수 있다. 이는 나비 떼가 짝을 만나기 위해 hilltop을 향해 이동하는 모양이 통로처럼 보여 붙여진 이름이다. Butterfly Hilltopping 모델은 가상의 corridors에 대해 설명하기 위해 디자인되었다. 즉, 나비들이 hilltop을 향해 움직이는 행동이 조건으로 주어졌을 때, landscape의 지형이 가상의 corridors의 발현(emergence)을 이끄는지 시뮬레이션 해보는 것이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly2.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
이 모델은 나비와 지형 두 가지 개체(entity)를 가지고 지형마다 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;고도(elevation)&lt;/b&gt;라는 상태 변수(state variable)를 가진다. 나비들은 각자의 위치에 의해 특정되고 시뮬레이션은 1000번째 스텝까지만 지속한다. 이 모델의 프로세스는 나비들의 움직임이고 스텝 한번에 한번 움직이며 나비끼리 상호작용은 없기 때문에 움직임의 순서는 중요하지 않다. 그러나 나비들이 위를 향해 움직일 때 항상 직진으로 움직이지 않기 때문에 나비가 움직이는 방향에 대한 randomness를 추가해준다. 여기서는 파라미터 &lt;i&gt;q&lt;/i&gt;로 이를 조절한다. 그리고 가상의 corridors를 관찰하기 위해 구체적인 corridor width(시작점부터 꼭대기까지 나비가 날아간 경로의 길이)를 정의한다. 지형의 고도는 인공적으로 만들어서 적용할 수도 있고(왼쪽 그림), 실제 연구 자료의 데이터를 사용(오른쪽 그림)할 수도 있다. 

&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM5/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM5/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Getting Started with NetLogo</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
기초 연습 (Elementary Exercises)
&lt;/span&gt;
&lt;br /&gt;
&lt;ol&gt;
&lt;li&gt;전체 view 화면을 파란색으로 바꾸기 : &lt;code&gt;ask patches [set pcolor blue]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 위치(0,0) patch를 빨간색으로 바꾸기 : &lt;code&gt;ask patch 0 0 [set pcolor red]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 위치(0,5)에 turtle 1개 만들기 : &lt;code&gt;create-turtles 1 [ setxy 0 5 ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;모든 turtle들을 1만큼 앞으로 움직이기 : &lt;code&gt;ask turtles [fd 1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;모든 turtle들의 방향(heading) 우측으로 바꾸기 : &lt;code&gt;ask turtles [set heading 90]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;turtle 1의 색깔, 사이즈, 모양 바꾸기 : &lt;code&gt;ask turtle 1 [set size 5 set shape &quot;cat&quot; set color yellow]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;초기화하기 : &lt;code&gt;clear-all&lt;/code&gt;또는 &lt;code&gt;ca&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;turtle이 움직인 경로 나타내기 : &lt;code&gt;pen-down&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL11.png&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL10.png&quot; width=&quot;270&quot; height=&quot;300&quot; /&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
이를 위와 같이 변수값은 global variable로 지정하여 interface에서 여러 값을 변환할 수 있게 할 수 있다. 또한 아래와 같이 위, 아래, 왼쪽, 오른쪽으로 turtle을 움직일 수 있고 주황색 부분은 통과할 수 없게 만들 수 있다. 
&lt;br /&gt; &lt;br /&gt;
&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL13.png&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL12.png&quot; width=&quot;270&quot; height=&quot;300&quot; /&gt;
&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.3em;&quot;&gt;
Neighbors
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
NetLogo에서 turtle이나 patch의 이웃은 다음과 같이 표현된다. neighbors를 사용하면 주변에 모든 patch가 선택되고 neighbors4를 사용하면 상하좌우 4개의 patch만 선택된다.&lt;br /&gt; &lt;br /&gt;
&lt;p style=&quot;text-align:center; &quot;&gt;
&lt;code&gt;ask turtle 0 [show count neighbors with [pcolor = green]]&lt;/code&gt;
&lt;br /&gt; 
&lt;code&gt;ask patch 0 0 [show count neighbors4 with [pcolor = green]]&lt;/code&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/NL14.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;
&lt;/p&gt;


&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM4/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM4/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Compelx Systems and Agent Based Modeling</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
시스템 (SYSTEM)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;시스템&lt;/b&gt;은 어떤 목적을 이루기 위해 함께 상호작용하고 행동하는 요소들의 집합이다. 시스템을 모델링하는 두 가지 측면이 있는데 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Aggregate View&lt;/b&gt; (Top-down approach)와 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Constituent View&lt;/b&gt; (Bottom-up approach)이다. Aggregate View는 target system의 프로세스, 내부 관계, 파라미터 등을 안다고 가정하는 것이고, 개인의 자유도는 보통 무시되며 (homogeneity) pre-determinded 구조를 가진다. Constituent View는 통합적인 것보다 각 요소의 성질이나 행동 (action, decision pattern 등)에 초점을 맞추며 진화하는 (evolving) 구조를 가진다.  
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
복잡한 시스템 (COMPLEX SYSTEMS)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Complex systems&lt;/b&gt;은 다양한 분야의 문제에 대한 접근방법을 포괄하는 광범위한 용어로 사용되므로 어느 한 가지로 정의하기 힘들다. 어떤 요소의 행동으로 단순히 complex systems의 행동을 예측하기는 힘들고 전체 시스템을 부분으로 나누어 각각을 이해하는 것도 옳지 않다. 즉, 단순하게 1+1은 2가 아니라고 생각하면 쉽게 연상할 수 있다. Complex systems는 중심적인 제어장치와 단순한 운영 규칙이 없는 거대한 네트워크이며 복잡한 집단 행동, 정교한 정보처리, 학습을 통한 적응이 이루어진다. 또한, nontrivial emergent 또는 자기 조직적 행동을 나타낼 수도 있다. 예를 들어 각 개인의 거래자가 시스템이라면 그 거래자들이 모인 마켓의 수요와 공급을 complex systems로 볼 수 있다. 또는 뉴런이 모인 뇌를 complex systems로도 볼 수 있으며 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;채찍효과(Bullwhip Effect)&lt;/b&gt;도 예시로 들 수 있다. 
&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL8.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL9.jpg&quot; width=&quot;280&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
채찍효과란 고객주문 정보가 상류로 전달되는 과정에서 정보가 왜곡되고 확대되는 현상을 말한다. 말그대로 채찍질하는 사람을 생각하면 이해하기 쉽다. 처음에는 채찍의 폭이 좁지만 갈수록 커지는 것과 같아 붙여진 이름이다. Complex systems에서는 초기 조건의 작은 차이(반올림에 따른 값의 차이 등)가 완전히 다른 결과를 초래할 수 있다. 마치 나비효과처럼 말이다. 
&lt;br /&gt;&lt;br /&gt;

Complex systems는 5가지 특성을 가지는데 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Non-linearity&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Interconnectedness&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Feedbacks&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Delays&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Heterogeneity&lt;/b&gt;이다. Input은 선형적인 방식으로 output에 영향을 미치는 것은 아니며 각각은 연결되어 있고 다른 결정에 영향을 미친다. 그러므로 각각을 하나씩 분리함으로써 문제를 풀 수는 없다. 또한, 시스템의 output에 따라 행동이 변할 수 있고, output이 input에 영향을 끼치기 위해 지연될 수 있으며, 각각은 여러가지 다양한 종류들로 이루어진다. Agent Based Model, System Dynamics, Network theory(complex networks) 모두 complex systems modeling이다.

&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
에이전트 기반 모델 (ABM)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

Complex systems에서 발생한 문제에 대한 답으로 단순한 모델은 더이상 충분하지 않다. &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;ABM&lt;/b&gt; (Agent Based Modeling)은 그에 대한 해답을 주는 주된 방법 중 하나이며, 시스템 전체에 미치는 영향을 평가하기 위한 목적으로 자율적인 에이전트의 행동과 상호작용을 시뮬레이션하는 계산 모델의 일종이다. 또한, 복잡한 현상의 출현을 re-create하고 예측하면서 동시다발적인 현상과 다수의 agent들의 상호작용을 시뮬레이션하는 microscale 모델의 일종이다. 
&lt;br /&gt;&lt;br /&gt;
여기서 Agent는 특정한 성질(property)이나 상태(state) 또는 행동(action)을 지닌 자율적이고 계산적인 객체를 의미하며 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Emergence&lt;/b&gt;는 다수의 분포된 element들의 상호작용을 통해 발생한 새롭고 일관적인 구조, 패턴, 성질을 의미한다. Emergent 구조는 element의 성질로 부터 단독으로 추론될 수 없고 element의 상호작용을 통해 생긴다. 또한, 어떠한 제어 요소없이 자발적으로 발생되기 때문에 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;self-organizes&lt;/b&gt;라고 할 수 있다. 에이전트 기반 모델링의 핵심은 어떤 현상에 대한 간단한 규칙을 찾아 emergence를 활용하는 것이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/v_shape.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/fish-flocking.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
Emergence의 예시로 자연현상에서 모티브를 받은 건축물, Fish Flocking (물고기들이 떼지어 헤엄치는 것), Bird Flocking (새들이 떼지어 날아다니는 것), 기러기떼가 V자 형태로 날아가는 것 등을 들 수 있다. NetLogo 모델의 example로 Flocking.nlogo 파일이 있으므로 참고해도 좋다. 이 모델은 새들이 떼지어 다니는 행동을 시뮬레이션하기 위해 Craig Reynolds가 1986년에 고안해낸 모델이다.
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/flocking.gif&quot; width=&quot;250&quot; height=&quot;250&quot; /&gt;
&lt;/p&gt;

이 모델에서는 새들의 움직임을 시뮬레이션하기 위해 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Separate&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Cohere&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Align&lt;/b&gt;의 특징을 가진다고 가정한다. Separate는 다른 모든 객체들과 최소 거리를 유지해야함을 뜻하고 Cohere는 flockmate를 향해 움직여야함을, Align은 flockmate와 같은 방향으로 움직여야함을 뜻한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
ABM 장점 및 단점 
&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
ABM은 복잡한 현상을 이해하기 쉽게 시각적으로 표현해주고 상호작용하는 요소들 사이의 연결을 잘 나태내어주는 장점을 가진다. 또한 귀납적(induction), 연역적(deduction)방법을 통합한 방법을 사용하여 알려진 전제들로 일반적인 이론을 만들기 위한 특정한 데이터 집합을 만들 수 있다. 우리가 알려진 하나의 전제를 알고 있을 경우 통합적인 패턴을 결정하는 것은 어렵지만 ABM은 이를 이해하기 쉽게 해주고, 반대로 통합적인 패턴을 알고 있을 경우에는 규칙을 제안하여 그 현상이 만들어지는지 확인함으로써 각각의 전제를 알 수 있도록 해준다. 
&lt;br /&gt;&lt;br /&gt;
그러나 ABM의 계산적인 모델은 예측가능한 결과를 주로 만들고 구체적인 상황에 근사적으로 맞춰져있으며 확실하지 않다. 또한, 계산 모델을 수정하고 이해하기가 쉽지 않다는 단점이 있다.
&lt;/div&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM3%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%87%E1%85%A9%E1%86%AB/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM3%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%87%E1%85%A9%E1%86%AB/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Compelx Systems and Agent Based Modeling</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
시스템 (SYSTEM)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;시스템&lt;/b&gt;은 어떤 목적을 이루기 위해 함께 상호작용하고 행동하는 요소들의 집합이다. 시스템을 모델링하는 두 가지 측면이 있는데 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Aggregate View&lt;/b&gt; (Top-down approach)와 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Constituent View&lt;/b&gt; (Bottom-up approach)이다. Aggregate View는 target system의 프로세스, 내부 관계, 파라미터 등을 안다고 가정하는 것이고, 개인의 자유도는 보통 무시되며 (homogeneity) pre-determinded 구조를 가진다. Constituent View는 통합적인 것보다 각 요소의 성질이나 행동 (action, decision pattern 등)에 초점을 맞추며 진화하는 (evolving) 구조를 가진다.  
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
복잡한 시스템 (COMPLEX SYSTEMS)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Complex systems&lt;/b&gt;은 다양한 분야의 문제에 대한 접근방법을 포괄하는 광범위한 용어로 사용되므로 어느 한 가지로 정의하기 힘들다. 어떤 요소의 행동으로 단순히 complex systems의 행동을 예측하기는 힘들고 전체 시스템을 부분으로 나누어 각각을 이해하는 것도 옳지 않다. 즉, 단순하게 1+1은 2가 아니라고 생각하면 쉽게 연상할 수 있다. Complex systems는 중심적인 제어장치와 단순한 운영 규칙이 없는 거대한 네트워크이며 복잡한 집단 행동, 정교한 정보처리, 학습을 통한 적응이 이루어진다. 또한, nontrivial emergent 또는 자기 조직적 행동을 나타낼 수도 있다. 예를 들어 각 개인의 거래자가 시스템이라면 그 거래자들이 모인 마켓의 수요와 공급을 complex systems로 볼 수 있다. 또는 뉴런이 모인 뇌를 complex systems로도 볼 수 있으며 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;채찍효과(Bullwhip Effect)&lt;/b&gt;도 예시로 들 수 있다. 
&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL8.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL9.jpg&quot; width=&quot;280&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
채찍효과란 고객주문 정보가 상류로 전달되는 과정에서 정보가 왜곡되고 확대되는 현상을 말한다. 말그대로 채찍질하는 사람을 생각하면 이해하기 쉽다. 처음에는 채찍의 폭이 좁지만 갈수록 커지는 것과 같아 붙여진 이름이다. Complex systems에서는 초기 조건의 작은 차이(반올림에 따른 값의 차이 등)가 완전히 다른 결과를 초래할 수 있다. 마치 나비효과처럼 말이다. 
&lt;br /&gt;&lt;br /&gt;

Complex systems는 5가지 특성을 가지는데 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Non-linearity&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Interconnectedness&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Feedbacks&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Delays&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Heterogeneity&lt;/b&gt;이다. Input은 선형적인 방식으로 output에 영향을 미치는 것은 아니며 각각은 연결되어 있고 다른 결정에 영향을 미친다. 그러므로 각각을 하나씩 분리함으로써 문제를 풀 수는 없다. 또한, 시스템의 output에 따라 행동이 변할 수 있고, output이 input에 영향을 끼치기 위해 지연될 수 있으며, 각각은 여러가지 다양한 종류들로 이루어진다. Agent Based Model, System Dynamics, Network theory(complex networks) 모두 complex systems modeling이다.

&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
에이전트 기반 모델 (ABM)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

Complex systems에서 발생한 문제에 대한 답으로 단순한 모델은 더이상 충분하지 않다. &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;ABM&lt;/b&gt; (Agent Based Modeling)은 그에 대한 해답을 주는 주된 방법 중 하나이며, 시스템 전체에 미치는 영향을 평가하기 위한 목적으로 자율적인 에이전트의 행동과 상호작용을 시뮬레이션하는 계산 모델의 일종이다. 또한, 복잡한 현상의 출현을 re-create하고 예측하면서 동시다발적인 현상과 다수의 agent들의 상호작용을 시뮬레이션하는 microscale 모델의 일종이다. 
&lt;br /&gt;&lt;br /&gt;
여기서 Agent는 특정한 성질(property)이나 상태(state) 또는 행동(action)을 지닌 자율적이고 계산적인 객체를 의미하며 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Emergence&lt;/b&gt;는 다수의 분포된 element들의 상호작용을 통해 발생한 새롭고 일관적인 구조, 패턴, 성질을 의미한다. Emergent 구조는 element의 성질로 부터 단독으로 추론될 수 없고 element의 상호작용을 통해 생긴다. 또한, 어떠한 제어 요소없이 자발적으로 발생되기 때문에 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;self-organizes&lt;/b&gt;라고 할 수 있다. 에이전트 기반 모델링의 핵심은 어떤 현상에 대한 간단한 규칙을 찾아 emergence를 활용하는 것이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/v_shape.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/fish-flocking.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
Emergence의 예시로 자연현상에서 모티브를 받은 건축물, Fish Flocking (물고기들이 떼지어 헤엄치는 것), Bird Flocking (새들이 떼지어 날아다니는 것), 기러기떼가 V자 형태로 날아가는 것 등을 들 수 있다. NetLogo 모델의 example로 Flocking.nlogo 파일이 있으므로 참고해도 좋다. 이 모델은 새들이 떼지어 다니는 행동을 시뮬레이션하기 위해 Craig Reynolds가 1986년에 고안해낸 모델이다.
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/flocking.gif&quot; width=&quot;250&quot; height=&quot;250&quot; /&gt;
&lt;/p&gt;

이 모델에서는 새들의 움직임을 시뮬레이션하기 위해 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Separate&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Cohere&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Align&lt;/b&gt;의 특징을 가진다고 가정한다. Separate는 다른 모든 객체들과 최소 거리를 유지해야함을 뜻하고 Cohere는 flockmate를 향해 움직여야함을, Align은 flockmate와 같은 방향으로 움직여야함을 뜻한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
ABM 장점 및 단점 
&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
ABM은 복잡한 현상을 이해하기 쉽게 시각적으로 표현해주고 상호작용하는 요소들 사이의 연결을 잘 나태내어주는 장점을 가진다. 또한 귀납적(induction), 연역적(deduction)방법을 통합한 방법을 사용하여 알려진 전제들로 일반적인 이론을 만들기 위한 특정한 데이터 집합을 만들 수 있다. 우리가 알려진 하나의 전제를 알고 있을 경우 통합적인 패턴을 결정하는 것은 어렵지만 ABM은 이를 이해하기 쉽게 해주고, 반대로 통합적인 패턴을 알고 있을 경우에는 규칙을 제안하여 그 현상이 만들어지는지 확인함으로써 각각의 전제를 알 수 있도록 해준다. 
&lt;br /&gt;&lt;br /&gt;
그러나 ABM의 계산적인 모델은 예측가능한 결과를 주로 만들고 구체적인 상황에 근사적으로 맞춰져있으며 확실하지 않다. 또한, 계산 모델을 수정하고 이해하기가 쉽지 않다는 단점이 있다.
&lt;/div&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM3/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM3/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Model, Modeling and Simulation</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
모델 (MODEL)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;모델&lt;/b&gt;은 어떤 것에 대한 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;추상화&lt;/b&gt;(또는 단순화)이다. Object, Process, Event, Concept 등이 대상이 될 수 있으며 추상화는 가정(assumptions)과 근사(approximations)를 포함한다. 모델은 복잡한 것들을 이해하고 다루기 위해 사용되며, 모델을 통해 다양한 아이디어들을 시도해 볼 수 있다. 또한, 모델을 연구하는 것이 현실세계에 직접 적용하는 것보다 더 쉽고 빠르며 저렴하고 안전하다는 장점이 있다. 때론 모델을 만드는 것 자체가 유익하고 직관력을 줄 수도 있다. 
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
모델링 (MODELING)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
모델을 만드는 과정을 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;모델링&lt;/b&gt;이라고 하며 모델링의 목적은 현실 세계의 문제들을 이해하거나 풀기 위함이다. 현실 세계의 문제는 솔루션을 바로 구해 적용하기 매우 어렵기 때문에 모델을 통해 시뮬레이션 해보고 비로소 현실세계에 적용한다. 모델은 다음과 같이 다양한 타입들이 있다. 

&lt;ul&gt;
&lt;li type=&quot;circle&quot;&gt;Physical Model  &lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Conceptual Model (Mental Model, Graphical Model)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Mathematical / Analytical Model&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Computational / Numerical Model&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

개념적 모델(conceptual model)은 계산적 모델(computational model)을 실행하기 위한 첫번째 단계이다. Flow chart와 같이 어떻게 모델의 구조를 디자인할지 결정하는 가장 기본적인 단계이며 계산적 모델은 수치적인 방법(numerical method)을 통해 분석적인 모델을 푸는 것이다. 예를 들어 어떤 방정식을 풀기 위한 알고리즘을 푸는 것, 엑셀과 같이 분석적인 솔루션을 구하는 것, 분석적으로 풀기 불가능한 문제를 푸는 것(시뮬레이션) 등을 들 수가 있다. 수리 모형(mathematical model)은 수리적 공식(mathematical formula)을 이용하여 reality를 설명하도록 하는 것이다. &lt;strike style=&quot;color:grey;font-size:0.5&quot;&gt; 수리모형을 활용하는 것이 나의 주 전공이기도 하다..^^;&lt;/strike&gt;
&lt;br /&gt;&lt;br /&gt;
매우 크고 복잡한 문제는 분석적인(analytic) 솔루션이 존재하지 않고 찾기도 매우 힘들다. 계산적 모델을 사용한 시뮬레이션은 분석적 모델(수리 모형)보다 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;복잡성&lt;/b&gt;(complexity)을 더 잘 표현할 수 있다. 분석적 모델은 수치적 모델 보다 더 엄격한 가정(strict assumptions)이 요구되고 순간적인 행동을 거의 표현할 수 없다. 즉, No Dynamic Situation이다. 모델링의 cycle은 다음과 같이 이루어진다.  

&lt;ol&gt;
&lt;li&gt;문제를 공식화한다. (Formulate the question/problem) &lt;/li&gt;
&lt;li&gt;필수적인 과정과 구조에 대한 가설들을 모은다. (Assemble hypotheses for essential processes and structures)  &lt;/li&gt;
&lt;li&gt;모델 구조를 선택한다. (Choose model structure)  &lt;/li&gt;
&lt;li&gt;모델을 실행한다. (Implement the model) &lt;/li&gt;
&lt;li&gt;모델을 분석하고 테스트하고 수정한다. (Analyze, test, and revise the model) &lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
시뮬레이션 (SIMULATION)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;What-if&lt;/b&gt; 조건하에서 모델의 행동을 연구하는 것이 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;시뮬레이션&lt;/b&gt;이다. 여기서는 주로 logical simulation을 다루며 이는 적절한 소프트웨어의 컴퓨터 프로그램을 통해 나타내어진다. 주로 어떤 것에 대해 시도해보거나, 결과를 얻거나 모델 행동에 대해 배우기 위해 프로그램을 실행한다. 시뮬레이션 타입은 다음과 같이 나뉠 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;div style=&quot;font-weight:500; font-size:1.1em; text-align:center; &quot;&gt;
&lt;b&gt;Static &lt;/b&gt; vs  &lt;b&gt;Dynamic&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;Continuous &lt;/b&gt; vs &lt;b&gt; Discrete&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;Deterministic &lt;/b&gt; vs &lt;b&gt; Stochastic&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL7.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL6.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;br /&gt;
대부분의 시뮬레이션 모델링은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;dynamic&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;discrete-change&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;stochastic&lt;/b&gt;한 특징을 가진다. 위의 그림은 scale의 추상화 정도와 시뮬레이션 모델링의 응용분야를 나타낸다. 추상화 정도가 높으면 detail이 적은 Macro level이며 추상화 정도가 낮으면 detail이 많은 Micro level이다. ABM은 그 중에서도 모든 추상화 범위를 아우를 수 있는 방법 중 하나이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM2/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM2/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - NetLogo Primer</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/NL.png&quot; width=&quot;400&quot; height=&quot;100&quot; /&gt;
&lt;/p&gt;
&lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;NetLogo&lt;/b&gt;는 agent-based modeling 언어로 주로 자연 현상이나 사회 현상에 대해 시뮬레이션 할 때 사용되며 배우기 쉬운 ABM tool 중 하나이다. 디자인 원칙으로 Low threshold 와 High ceiling이 있다. Low threshold는 처음 사용하는 사람들도 간단한 모델을 만들 수 있다는 의미이고 High ceiling은 high end complex 모델을 가능하게 할 만큼 충분히 표현되어야 하며 논문 출간시 사용될 수 있다는 의미이다. NetLogo는 &lt;a href=&quot;https://ccl.northwestern.edu/netlogo/&quot; style=&quot;color:#d7385e;font-size:1.2&quot;&gt;홈페이지&lt;/a&gt;에서 다운받을 수 있으며 사용자 인터페이스는 다음과 같다. 
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL3.png&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL2.png&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

까맣게 보이는 창을 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;world &lt;/b&gt; 라고 하며 agent인 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;turtle&lt;/b&gt;이 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;patch&lt;/b&gt;들로 이루어진 grid위에서 움직일 수 있다. edit을 누르면 world의 설정을 바꿀 수 있다. NetLogo의 기본적인 요소로 turtles, patches, links, observer가 있으며 각각의 특징은 다음과 같다. 
&lt;ul&gt;
&lt;li type=&quot;circle&quot;&gt;Turtles : 동적인 에이전트이며 각각은 독립적으로 표현되고 좌표는 실수(real number)값을 가진다.  &lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Patches : 정적인 에이전트이며 공간(space)으로 표현되고 좌표는 항상 정수(integer)값을 가진다. &lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Links : 에이전트는 서로 링크되어 연결될 수 있다. &lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Observer : 유저 인터페이스의 맨 아래를 보면 observer가 있다. 이 창을 통해 world를 관찰하고(observe), 통제하고(control), 명령하는 것(command)이 가능하다.  &lt;/li&gt;
&lt;/ul&gt;
NetLogo 모델 타입은 크게 3가지가 있다. Patch만으로 이루어진 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Patch only&lt;/b&gt;, turtle만으로 이루어진 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Turtle only&lt;/b&gt;, patch와 turtle 모두로 이루어진 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Patch and Turtle&lt;/b&gt;이 있다.
&lt;br /&gt;&lt;br /&gt;
NetLogo의 화면 위쪽에는 Interface, Info, Code의 3가지 탭이 있다. Interface는 에이전트와 옵저버를 연결하는 역할을 하고 (즉, 첫 화면에서 world의 환경을 구성하고 실행하는 것) Info에는 NetLogo 모델에 대한 간략한 정보들이 있으며 code에서는 모델을 프로그래밍 하는 코드를 넣을 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/NL4.png&quot; width=&quot;350&quot; height=&quot;300&quot; /&gt;
&lt;/p&gt;
&lt;br /&gt;Interface 탭에서는 위와 같이 시뮬레이션 모델 실행을 통제할 수 있는 Button, Input, 파라미터 값을 설정할 수 있는 Silder, Switch, Chooser, 시뮬레이션 결과를 시각화해주는 Monitor, Plot, Output, Note 등을 생성할 수 있다. 
&lt;br /&gt;&lt;br /&gt;



&lt;/div&gt;
</description>
        <pubDate>Sun, 05 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM1/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM1/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>논문리뷰 - Symmetry helps: Bounded bi-directional dynamic programming for the elementary shortest path problem with resource constraints</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Abstract &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
When &lt;u&gt;vehicle routing problems&lt;/u&gt; with additional constraints, such as capacity or time windows, &lt;u&gt;are solved via column generation and branch-and-price&lt;/u&gt;, it is common that the pricing subproblem requires the computation of a minimum cost constrained path on a graph with costs on the arcs and prizes on the vertices. A common solution technique for this problem is dynamic programming. In this paper we illustrate how the basic dynamic programming algorithm can be improved by &lt;u&gt;bounded bi-directional search&lt;/u&gt; and we experimentally evaluate the effectiveness of the enhancement proposed. We consider as benchmark problems the elementary shortest path problems arising as pricing subproblems in branch-and-price algorithms for the capacitated vehicle routing problem, the vehicle routing problem with distribution and collection and the capacitated vehicle routing problem with time windows.&lt;br /&gt;&lt;br /&gt;
&lt;em&gt;Keywords : Shortest path; Vehicle routing; Dynamic programming; Column generation &lt;/em&gt; 
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Summary
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:5%; &quot;&gt;

 추가적인 제약이 있는 VRP (Vehicle Routing Problem)는 CG (Column Generation)와 BnP (Branch-and-Price)를 사용해서 풀 수 있는데 솔루션 기법으로써 다이나믹 프로그래밍을 사용한다. 이 논문에서는 RCESPP (Resource Constrained Elementary Shortest Path Problem)를 exact하게 풀기 위한 방법으로 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;bounded bi-directional dynamic programming&lt;/b&gt; 을 제안한다. 3가지 유형의 VRP (CVRP, VRPDC, CVRPTW) 를 Solomon 데이터를 사용하여 실험하며 실험결과 기존의 mono-directional 알고리즘보다 우수한 성능을 가짐을 보인다. 
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;본문 내용
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:5%; &quot;&gt;

VRP란 주어진 고객들을 모두 방문하는 차량 경로들의 집합을 구하는 문제이다. 목적함수는 총 비용(거리)를 최소화하는 경로를 찾는 것이다. Column generation을 적용하기 위해 set covering 문제로 reformulation을 하는데 이렇게 하는 이유는 매우 타이트한 lower bound를 줄 수 있기 때문이다. 
&lt;/div&gt;

&lt;div&gt;

$$
\begin{align}
    \min \quad &amp;amp; \sum_{f \in \mathcal{F}} c_f z_f \notag  \\
    \text{s.t.} \quad
    &amp;amp; \sum_{f \in \mathcal{F}} x_if z_f \ge 1 \quad \forall i \in \mathcal{N} \\
    &amp;amp; - \sum_{f \in \mathcal{F}} z_f \ge -V \\
    &amp;amp; z_f \in \{0,1\}, \quad \forall f \in \mathcal{F}
\end{align}
$$

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; &quot;&gt;

여기서 모든 경로의 집합인 $\mathcal{F}$의 개수가 매우 많기 때문에 column generation에서 reduced cost가 음수인 경로만 찾아서 추가해야한다. 더 이상 reduced cost가 음수인 경로가 없으면 column 추가를
 멈춘다. 이 논문에서는 2가지 bound를 사용하며 각각은 다음과 같다. 
&lt;/div&gt;
&lt;br /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:center; text-indent:0%; &quot;&gt;

&lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;
Fathoming unpromising states &lt;br /&gt;
Stopping the extension of the non-dominated states &lt;br /&gt;&lt;br /&gt;
&lt;/b&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; &quot;&gt;

첫 번째는 말 그대로 가망없는 상태는 고려하지 않는 것이고 두 번째는 지배되지 않는 상태의 확장을 멈추는 것이다. 즉, 더 이상 branching할 필요가 없다고 판단되는 상태를 일찍 파악해서 불필요한 branching을 줄이는 것이다.
&lt;/div&gt;
&lt;br /&gt;
&lt;div style=&quot;font-weight:300; font-size:0.9em; margin-left: 1em; margin-right: 1em;text-align:center; text-indent:0%; &quot;&gt;
(이 논문에서 reduced cost를 구할 때 $\lambda$를 2로 나누는 이유는 bi-directional이라 symmetry를 만들기 위함이다.)
&lt;/div&gt;
&lt;br /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; &quot;&gt;
앞서 3가지 VRP에 대해 실험한다고 했는데 각각은 CVRP (Capacitated vehicle routing probelm), VRPDC (vehicle routing problem with distribution and collection), CVRPTW (capacitated vehicle routing problem with time windows)이다. CVRP는 용량인 capacity만 고려하는 문제, VRPDC는 distribution과 collection을 고려하는 문제, CVRPTW는 capacity와 time windows를 고려하는 문제이다. 각각의 문제에 대해 제약을 만족하면서 완전한 경로가 되도록 state를 확장한다. 특히 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;dominance test&lt;/b&gt;는 이 알고리즘에서 굉장히 중요한 부분이다. 두 개의 레이블 $l_1 (S_1,R_1,C_1,i)$ 과 $l_2 (S_2,R_2,C_2,i)$에 대해 다음을 만족하면 $l_1$은 $l_2$를 지배한다. (여기서 $S$는 방문한 노드를 나타내는 벡터, $R$은 자원 소모를 나타내는 벡터, $C$는 cost를 나타낸다.)   
&lt;br /&gt;&lt;br /&gt;

&lt;!-- &lt;img src=&quot;/images/post_img/a1.jpg&quot;&gt; --&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:center; text-indent:0%; &quot;&gt;

$$
\begin{align}
    &amp;amp; S_1 \le S_2 \notag\\
    &amp;amp; R_1 \le R_2 \notag\\
    &amp;amp; C_1 \le C_2 \notag\\
\end{align}
$$
&lt;/div&gt;

&lt;br /&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; &quot;&gt;
    위의 지배규칙을 적용하여 확장 가능한 노드로 계속 확장하면서 가능한 label의 집합을 구하는 다이나믹 알고리즘을 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;레이블링 알고리즘 (labeling algorithm)&lt;/b&gt; 이라고도 부른다. 더 이상 시행할 노드가 없을 때까지 반복한다. RCESPP의 mono-directional dynamic programming의 수도코드 (pseudocode)는 다음과 같다. 
    &lt;br /&gt;&lt;br /&gt;
    &lt;img src=&quot;/images/post_img/a1.jpg&quot; /&gt;
    여기서 &lt;i&gt;&lt;b&gt;Extend&lt;/b&gt;&lt;/i&gt; 함수와 &lt;i&gt;&lt;b&gt;EFF&lt;/b&gt;&lt;/i&gt; 함수에서 다른 state로 확장시 자원 제약에 대해 확인하고 dominace test를 적용하여 state 추가 여부를 결정한다. 

    &lt;br /&gt;&lt;br /&gt;

    그러나 이러한 방법은 노드의 개수가 증가하면 label의 개수가 기하급수적으로 증가하기 때문에 계산시간이 급격하게 증가한다. 따라서 이 논문에서 bi-directional dynamic programming을 제안한 것이다. 고려해야할 state가 매우 많기 때문에 이를 절반으로 나누어 구하자는 생각이다. 즉, 시작노드와 끝노드에서 절반씩 경로를 구한 뒤 이를 합쳐 하나의 경로로 만드는 것이다. 이러한 방법은 기하급수적으로 많은 state를 다루지 않도록 해준다. Bi-directional dynamic programming의 수도코드는 다음과 같다. 
    &lt;br /&gt;&lt;br /&gt;
    &lt;img src=&quot;/images/post_img/a2.jpg&quot; /&gt;
    mono-directional과 전체적으로 유사하며 &lt;b style=&quot;color:#d7385e;&quot;&gt;Forward&lt;/b&gt; 와 &lt;b style=&quot;color:#d7385e;&quot;&gt;Backward&lt;/b&gt;로 나누어 경로를 구하는 것이 다른 점이다. 여기서는 특정 방향 외의 다른 방향에서 path의 나머지 부분이 생긴다고 가정할 수 있다면 특정 방향으로는 확장을 하지 않아도 되고 optimal solution도 보장할 수 있음을 주장한다. 이를 위해 bounding에서는 optimal solution이 아닌 state를 알아내고 forward나 backward path의 확장을 멈추는 규칙을 적용한다. bi-directional 알고리즘에서 &lt;i&gt;&lt;b&gt;Join&lt;/b&gt;&lt;/i&gt; 함수의 수도코드는 다음과 같다. 
    &lt;br /&gt;&lt;br /&gt;
    &lt;img src=&quot;/images/post_img/a3.jpg&quot; /&gt;
    이 알고리즘에서는 두 개의 path를 합치는 과정에서 중복된 솔루션이 포함될 수 있다. 중복된 솔루션이 생기면 계산적으로 비효율적이기 때문에 이를 방지하기 위해 &lt;i&gt;&lt;b&gt;Halfway&lt;/b&gt;&lt;/i&gt;를 고안하였다. 이는 forward와 backward로 결합된 path의 state가 half-way point에 가능한 가깝도록 하는 것이다. 즉, 가장 symmetry한 조합으로 두 개의 경로를 하나로 합치는 것이다. 
    &lt;br /&gt;&lt;br /&gt;
    실험결과 mono-directional에 비해 bi-directional이 확장되는 state의 총 개수도 적고 계산 시간도 더 빠른 편임을 보인다. 또한, 3600초 time-limit안에 mono-directional로 풀 수 없는 문제를 bi-directional으로 푼 경우도 있으므로 더 우수한 성능을 가졌다고 볼 수 있다. 
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Cite
&lt;/div&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; font-family: Times New Roman; &quot;&gt;
Righini, G., &amp;amp; Salani, M. (2006). Symmetry helps: Bounded bi-directional dynamic programming for the elementary shortest path problem with resource constraints. &lt;i&gt;Discrete Optimization, 3&lt;/i&gt;(3), 255-273. 
&lt;/span&gt;
&lt;span style=&quot;font-weight:400; font-size:1.0em;&quot;&gt;
&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S1572528606000417&quot;&gt; 논문 링크 &lt;/a&gt;
&lt;/span&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;



&lt;/div&gt;
</description>
        <pubDate>Thu, 02 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/%E1%84%82%E1%85%A9%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%87%E1%85%B21/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/%E1%84%82%E1%85%A9%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%87%E1%85%B21/</guid>
        
        
        <category>논문리뷰</category>
        
      </item>
    
  </channel>
</rss>
