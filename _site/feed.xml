<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>코딩새내기 일상일지</title>
    <description>github blog</description>
    <link>http://munjeongkang.github.io/</link>
    <atom:link href="http://munjeongkang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 10 Apr 2020 15:34:53 +0900</pubDate>
    <lastBuildDate>Fri, 10 Apr 2020 15:34:53 +0900</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>인공신경망 - Learning Algorithms. The Task, T</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;머신러닝(machine learning)&lt;/b&gt;은 사람에 의해 디자인된 프로그램(fixed programs)으로 풀기 너무 어려운 일(task)을 다룰 수 있도록 해준다. 스스로 배우는 과정은 task가 아니며 머신러닝 task는 일반적으로 머신러닝 시스템이 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;예시&lt;/b&gt;(example)를 어떻게 처리해야하는지에 관한 것이다. 하나의 예시로 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;특징&lt;/b&gt;(features) $x_i$를 모으는 것이 있다. 이를 특징 추출(feature collection)이라고 하며 이미지의 특징은 주로 픽셀(pixel)의 값이다.
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
분류 (Classification)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
입력값을 $k$개의 카테고리로 구체화하기 위한 방법이다. 분류의 예시로 객체인식 (object recognition)이 있으며 이는 이미지가 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;input&lt;/b&gt;으로 주어졌을 때 이미지 속 객체를 인식하는 수치적인(numeric) 코드가 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;output&lt;/b&gt;으로 나오는 것이다. 알고리즘을 학습하는 것은 $f : \mathbb{R}^{n} \rightarrow\{1, \ldots, k\}$와 같이 함수를 만드는 것이고, $y=f(x)$일 때 input인 vector $x$에 의해 나온 output $y$에 따라 카테고리가 할당된다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
누락된 입력이 있는 분류 (Classification with Missing Inputs)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
누락된 입력이 있는 경우, 하나의 분류 함수만 사용하지 말고 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;함수 집합&lt;/b&gt; (Set of Functions)으로 알고리즘을 학습시켜야 한다. 함수 집합은 누락된 입력에 대해 각각 다른 부분집합을 가지는 $x$에 대한 함수들이다. 만약 함수 집합의 크기가 크다면 관련된 모든 변수를 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;확률 분포&lt;/b&gt;로 학습시키는 것이 누락된 변수를 무시할 수 있어 더 좋다. $n$개의 입력변수에 대해 $2^n$개의 분류 함수를 모두 포함할 수도 있지만 알고리즘을 학습시키기 위해 확률 분포가 결합된 단일 함수가 필요하다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
회귀분석 (Regression)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
주어진 입력값의 수치적인 값을 예측하기 위한 방법이다 ($f : \mathbb{R}^{n} \rightarrow \mathbb{R}$). Output의 포멧이 다르다는 점을 제외하고 분류(classification)와 비슷하다. 예를 들어 피보험자가 부담하게 될 예상 청구 금액 등을 예측하는데 사용할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
전사 (Transcription)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
상대적으로 구조적이지 않은 종류의 데이터를 개별적인 원문(textual) 형식으로 바꾸는 것이다. 예시로는 광학적 문자 인식 (optical character recognition), 음성 인식 (speech recognition) 등이 있다.  
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
기계번역 (Machine Translation)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
입력값은 이미 어떤 언어 규칙 순서로 구성되어 있고 컴퓨터 프로그램은 이를 다른 언어 규칙 순서로 변환해야한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
구조적 출력 (Structured Output)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
Structured Ouput은 각 요소들 사이의 중요한 관계를 가지는 벡터나 다수의 값을 포함하는 또 다른 데이터 구조이다. 이것은 넓은 범주로 전사(transcription)와 번역(translation) 작업을 포함한다. 예를 들어 구문 분석이나, 픽셀별로 이미지를 분할하는 것 등이 있다.   
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
이상 감지 (Anonmaly Detection)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
컴퓨터 프로그램은 일련의 사건이나 객체에 대해 살피면서 비정상적이거나 이례적인 것을 찾아 표시한다. 예를 들어 신용카드 사기를 감지하는 것이 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
합성 및 샘플링 (Synthesis and Sampling)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
트레이닝 데이터와 유사한 새로운 예제를 생성하는 방법이다. 예를 들어 음성 합성 (speech synthesis) 등이 있고 구조적 출력 작업의 일종이지만 추가적인 조건(qualification)이 있다. 각 인풋에 대해 유일한 아웃풋은 없고 아웃풋이 더 자연스럽고 사실적으로 보이도록 많은 양의 변화를 준다.   
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
누락값 대체 (Imputation of Missing Values)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
새로운 예시 $x \in \mathbb{R}^n$가 주어지지만 $x$의 일부 항목 $x_i$가 누락되어 있다. 알고리즘은 누락된 항목값에 대한 예측을 포함해야한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
노이즈 제거 (Denoising)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
노이즈가 없는 clean example $x \in \mathbb{R}^n$에 알 수 없는 변형이 생겨 입력값에 변질된 example $\tilde{x} \in \mathbb{R}^{n}$이 포함되어 주어지는 경우가 있다. 따라서 변질된 $\tilde{x}$로 부터 clean한 $x$를 예측하거나 좀더 일반적으로 조건부 확률 $p(x|\tilde{x})$을 예측한다.
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;

Density Estimation or Probability Mass Function Estimation
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
함수 $ p_{model} : \mathbb{R}^n \rightarrow \mathbb{R}$에서 $p_{model}$은 $x$가 연속(continuous)일 경우 확률밀도함수(pdf), $x$가 이산(discrete)일 경우 확률질량함수(pmf)로 해석된다. example들이 어디에서 타이트하게 군집화되는지와 어디서 발생할 가능성이 낮은지 알아야 한다. 그러면 다른 task들도 해결할 수 있는 분포에 대한 계산을 수행할 수 있다.
&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;
</description>
        <pubDate>Thu, 09 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ANN1/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ANN1/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Prediction</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Prediction
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
ABM의 adaptive한 특성은 항상 예측을 포함한다. 예측은 각 대안의 결과에 대한 기대이고 아주 간단한 에이전트의 결정도 예측을 포함한다. 심지어 극단적으로 간단한 예측을 사용해도 complex behavior가 나타날 수 있다. ABM의 핵심 부분을 만들기 위해 test와 explore로 submodel을 분리하는 것이 시간과 노력을 아낄 수 있고, 모든 가능한 조건하에서 행동을 실행해볼 수 있다는 장점이 있다. 
&lt;br /&gt;&lt;br /&gt;
앞서 살펴본 비즈니스 투자모델의 목적함수를 다음과 같이 바꾸어 실행해볼 수 있다. 여기서 control variable은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;decision-time-horizon&lt;/b&gt;이다.
&lt;ol&gt;
&lt;li&gt;수익과 위험을 모두 고려하여 예상되는 투자자의 자산을 최대화하는 것&lt;br /&gt;
utility = turtles-wealth + (profit * &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;decision-time-horizon&lt;/b&gt;) &lt;br /&gt;
if utility $\le$ 0 then report 0, else &lt;br /&gt;
utility = utility * ((1-annual-risk) * &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;decision-time-horizon&lt;/b&gt;) &lt;/li&gt;
&lt;li&gt;위험은 무시하고 수익만을 최대화 하는 것 &lt;br /&gt;
utility = profit&lt;/li&gt;
&lt;li&gt;마이너스 수익과 위험을 피하는 것&lt;br /&gt;
utility = turtles-wealth + (profit * &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;decision-time-horizon&lt;/b&gt;) &lt;br /&gt;
if utility $\le$ 0 then report 0, else &lt;br /&gt;
utility = utility * ((1-annual-risk)^&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;decision-time-horizon&lt;/b&gt;)&lt;/li&gt;
&lt;/ol&gt;
이 때 투자자의 자산은 다음과 같이 계산된다. wealth = 0 인 경우에는 실패로 카운트한다. 
&lt;ul&gt;
wealth = wealth + profit &lt;br /&gt;
if wealth $\le$ 0 then wealth = 0 &lt;br /&gt;
if random-float 1.0 &amp;lt; annual-risk then wealth = 0 
&lt;/ul&gt;
실험 결과 투자자들은 decision-time-horizon에 상관없이 시뮬레이션이 진행됨에 따라 위험도가 낮은 투자쪽으로 이동한다.  
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Submodel
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
Submodel로 분리하여 분석하는 것은 ABM의 각 부분을 시험하고 완전히 이해하도록 돕는 역할을 하기 때문에 중요하다. 투자 모델에서는 투자자의 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;utility&lt;/b&gt; 값이 투자 수익과 실패 위험에 따라 어떻게 변하는지 알고 싶어한다. 이 때 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;등고선도(contour plots)&lt;/b&gt;를 그려보면 파라미터를 동시에 고려하여 어떻게 submodel이 행동했는지 알 수 있다. 동일한 등고선에 속하는 이익과 위험의 조합은 동일한 효용을 제공한다.

&lt;br /&gt;&lt;br /&gt;
Current investor wealth = 0, Time horizon = 5인 경우 &lt;br /&gt;
효용(utility)은 이익(profit)에 따라 크게 다르지만 위험(risk)에 대해서는 거의 다르지 않다.&lt;br /&gt;&lt;br /&gt;

Current investor wealth = 100000, Time horizon = 5인 경우&lt;br /&gt;
효용(utility)은 이익(profit)과 위험(risk) 모두에 따라 영향을 받는다. 이 경우 실패하면 비용이 더 들기 때문에 투자자가 돈을 더 가지고 있을 때 위험이 좀 더 중요한 요소가 된다. 투자자들은 전체 자산을 잃는 위험을 줄이기 위해 negative income을 선택할 수도 있다. 투자자가 자산을 축적할 때 손실을 흡수하여 위험을 줄일 수 있는 이 선택은 시뮬레이션을 하는 동안 투자자가 왜 저소득(lower-income), 저위험(lower-risk) 투자로 이동하는지 설명한다.&lt;br /&gt;&lt;br /&gt;

Current investor wealth = 0, Time horizon = 25인 경우&lt;br /&gt;
등고선이 (1)의 경우 보다 더 곡선이다. 이익과 위험사이의 trade-off는 투자자가 낮은 위험에서 높은 위험으로 가거나 낮은 이익에서 높은 이익으로 전환함에 따라 더 많이 변화한다. 이익이 낮을 때는 효용이 이익에만 민감하지만, 이익의 값이 높아질수록 효용이 위험에 점점 더 의존하게 되고 등고선의 모양은 점점 더 수평이 된다. &lt;br /&gt;&lt;br /&gt;

Current investor wealth = 100000, Time horizon = 25인 경우&lt;br /&gt;
이익이 -4000이하인 경우 효용은 0이고 (2)와 대조적이다. time horizon이 길수록 투자자들은 위험 감소에 대한 대가로 단기 손실을 감수하지 않게 된다. 이는 직관에 어긋나는 결과이다. (counterintuitive)
이런 결과가 나타난 이유는 에이전트인 투자자가 선택하는 투자 이익과 위험은 매년 변화할 기회가 있음에도 불구하고 내내 지속될 것이라는 잘못된 예측을 사용하기 때문이다. &lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;
</description>
        <pubDate>Thu, 09 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM11/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM11/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Adaptive Behavior and Objectives</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Adaptive Behavior 
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Adaptive Traits&lt;/b&gt;를 최적화하는 과정은 다음과 같다. 
&lt;ol&gt;
&lt;li&gt;대체할 수 있는것(alternatives)이 확인한다.&lt;/li&gt;
&lt;li&gt;유효하지 않은 것은 제거한다.&lt;/li&gt;
&lt;li&gt;각각의 alternatives가 목적 함수를 얼마나 충족하는지에 따라 유효한 것을 평가한다.&lt;/li&gt;
&lt;li&gt;가장 좋은 목적함수 값을 주는 최적의 alternative를 선택한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li type=&quot;circle&quot;&gt;Agentset (대체할 수 있는 후보) : turtles, links, turtles-at, turtles-on, turtle-here, link-neighbors, in-link-neighbors, out-link-neighbors 등 &lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Agentset의 부분집합 만들기 : other, in-radius, in-cone, with, with-max, max-n-of, with-min, and, or, patch-set, turtle-set, link-set 등&lt;/li&gt;
&lt;/ul&gt;
max-one-of, min-one-of, with-max, with-min 등을 사용하여 목적함수에 대해 가장 좋은 alternative를 확인한다. 비즈니스 투자 모델의 경우 매년 투자자는 유효한(feasible) 투자의 효용을 계산하고 가장 좋은 투자를 선택한다. 이 모델의 목적은 최대 효용을 가지는 항목에 투자를 함으로써 자산을 최대화 하는 것이다. 이 때, 투자자들은 유효한 투자의 수익에 대한 정보는 가지고 있다고 가정한다.
&lt;br /&gt;&lt;br /&gt;
 이 모델에 대한 새로운 파라미터로 profit-mulriplier(0.5~1.0)와 risk-multiplier(1.0~2.0)를 추가해서 분석해 보면 다음과 같은 결과를 얻을 수 있다. 어느 한 가지는 고정하고 값을 변화시켰을 때 위험과 이익이 변하는 양상을 볼 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL20.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL19.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Satisficing decision
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;

Alternative를 찾을 때 꼭 최적의 값을 찾지 않아도 되는 경우가 있다. 이 때는 적당히 좋은 값(good enough)을 찾는다. 비즈니스 투자 모델의 경우 투자자들은 그들이 소유한 종목 이외의 이익이나 실패 위험을 알 수 없다. 그렇기 때문에 적당한 한계점(threshold)을 기준으로 잡아 종목을 선택할지 말지 결정한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 09 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM10/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM10/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Sensing</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Sensing
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
에이전트가 어떤 정보를 가지고 있는지, 어떻게 그것을 얻었는지에 대한 것이 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Sensing&lt;/b&gt;이다. 에이전트는 주로 환경이나 다른 에이전트로 부터 정보를 얻고 그 정보에 의해 반응한다. 에이전트가 어떤 변수를 사용했는지, 무엇으로부터 정보를 얻었는지, 어떻게 정보를 얻었는지가 모델링 sensing의 핵심이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Scope of Variables
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
ABM에서 사용할 수 있는 변수들은 다음과 같다. 
&lt;ul&gt;
&lt;li type=&quot;circle&quot;&gt;Global Variables : 어떤 객체든지 항상 변할 수 있는 값이다. (Model-level, Environment parameters, Interface, Behavior space 등) &lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Patch Variables : &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;patches-own&lt;/b&gt; 사용가능, pcolor, pxcor 등 patch에 관련된 것을 사용한다. turtle은 그들이 위치한 patch의 변수에 직접적으로 접근가능하다.&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Turtle and Link Variables : &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;turtles-own&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;links-own&lt;/b&gt; 사용가능, 각각의 turtle 또는 link에만 한정된다.&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Local Variables : &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;let&lt;/b&gt; 명렁어를 사용하여 만들고 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;set&lt;/b&gt;을 사용하여 값을 변환시킨다. 객체가 생성되는 장소에서만 생성할 수 있으며, 다른 객체는 접근할 수 없다. procedure(또는 [])가 종료되면 사라진다. &lt;/li&gt;
&lt;/ul&gt;
다른 객체의 변수를 사용하는 예시로 다음의 코드를 사용할 수 있으며 이를 응용해 다음과 같이 서로의 색을 바꾸는 코드를 짤 수 있다.
&lt;br /&gt;
&lt;ul&gt;
&lt;code&gt;let max-neighbor-value max [value] of neighbors&lt;/code&gt; &lt;br /&gt;
&lt;code&gt;ask neighbors [set value 99]&lt;/code&gt; &lt;br /&gt;
&lt;code&gt;ask neighbors [set value ([value] of myself)]&lt;/code&gt;
&lt;/ul&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL18.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/switch.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
The Business Investor Model
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;비즈니스 투자 모델&lt;/b&gt;은 수익과 위험정도가 다른 투자 후보들이 있을 때, 어떤 것에 투자할지에 대해 시뮬레이션하는 것이다. 모델의 목적은 주어진 정보를 사용하여 모델의 emergent output에 대한 sensing의 영향을 알아보는 것이다. 여기서 turtle이 투자자, patch가 투자 후보들이다. turtle의 변수로 location, current wealth(&lt;i&gt;W&lt;/i&gt;)가 있고, patch의 변수로 annual net profit(&lt;i&gt;P&lt;/i&gt;), annual risk-probability of losing all its wealth(&lt;i&gt;F&lt;/i&gt;)가 있다. 모델의 time step은 1년이고 25년까지 실행한다. time step마다 투자자는 어떤 곳에 투자할지 선택하고 자산이 업데이트된다. 
&lt;br /&gt;&lt;br /&gt;
이 모델에서는 수익은 높이고 위험은 줄이는 선택을 어떻게 할 것인지 정해야한다. time step마다 투자자의 평균 자산,평균 수익, 위험, 실패한 투자자의 수가 output으로 나오고 수익과 위험 사이의 trade-off를 통해 발현된다. 투자자인 turtle은 투자 후보들 중에서 목적함수의 값을 최대화하는 이웃의 patch로 이동한다. (현재 위치가 제일 좋은 선택이면 움직이지 않는다.) 여기서 목적함수는 마지막에 예측되는 효용 (미래의 자산)을 최대화 하는 것이다. 여기서 $T$는 time horizon을 뜻한다.
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
$U = (W+TP)(1-F)^T$
&lt;br /&gt;
&lt;/p&gt;
투자자들은 그들의 patch와 인접한 이웃 patch의 수익과 위험을 안다고 가정하고, 이미 다른 투자자가 차지한 patch로는 이동하지 않는다. &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;F&lt;/i&gt;, &lt;i&gt;location&lt;/i&gt; 등 모델의 초기상태, 투자실패, 동률일 때 무작위로 움직이는 것 등은 확률적이며 에이전트의 위치, 평균 수익과 위험, 평균 투자자산, time step별 각 투자자의 상태를 관찰(observation)할 수 있다. 100명의 투자자가 랜덤으로 위치하고 &lt;i&gt;W&lt;/i&gt;의 초기값은 0이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/invest.gif&quot; width=&quot;600&quot; height=&quot;300&quot; /&gt;
&lt;br /&gt;
&lt;/p&gt;
여기서 만약 투자자들이 이웃만이 아닌 더 넓은 범위의 투자도 고려할 수 있다면 투자자의 자산을 더 증가시킬 수 있는지 의문이 든다. 실제로 Sensing range를 넓혀가면서 실험해보면 이웃만 살펴보는 것보다 더 넓은 범위를 고려하는게 더 좋다. 하지만 일정 범위를 지나서는 아무리 넓은 범위를 고려해도 투자 자산이 증가하지는 않는다. 
&lt;br /&gt;&lt;br /&gt;
 
&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM9/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM9/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Emergence</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
발현 (Emergence)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Emergence&lt;/b&gt;는 ABM의 가장 중요하고 독특한 특징으로, 복잡하고 예상치 못한 시스템 다이나믹스가 기본적인 프로세스를 모델링하는 방법에서 나온다는 것이다. 여기서 예상치 못한다는 뜻은 단순히 생각만으로 예측하기 어렵거나 불가능함을 뜻한다. Emergence는 단순히 모델 객체의 성질이 합쳐진 것도, 각각의 성질로부터 쉽게 예측될 수 있는 것도 아니다. 
&lt;br /&gt;&lt;br /&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/emergence.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL15.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
관련된 간단한 문제를 만들어보자. 40개의 turtle을 만들고 &#39;speed&#39; attribute를 추가한다. turtle들을 앞으로 10만큼 이동시키고 오른쪽으로 90도 돌리면 어떤 모양이 될까? 놀랍게도 왼쪽 그림과 같이 원 모양이 만들어진다. 이를 turtle의 속도만큼 앞으로 이동하고 오른쪽으로 1만큼 계속 돌리면 오른쪽 그림과 같이 원이 커졌다가 줄어드는 현상을 볼 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/birthrate.gif&quot; width=&quot;290&quot; height=&quot;250&quot; /&gt;
&lt;/p&gt;
&lt;br /&gt;
또 다른 예시로 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Simple Birth Rates Model&lt;/b&gt;을 들 수 있다. 이 모델은 두 개의 종 (빨간색 turtle, 파란색 turtle) 사이의 출생률 차이가 각 모집단의 객체수에 어떤 영향을 미치는지 시뮬레이션하기 위해 설계되었다. 두 종은 time step 마다 생산하는 자손의 수에만 차이가 있고 죽을 확률은 같다. 두 종의 상대적인 출생률에 따라 한 종이 멸종할 때까지 얼마나 시간이 걸리는지 알아본다. 이 모델에서 fertility를 조절하여 출생률을 바꿀 수 있으며, 예를 들어 fertility 3.4라면 최소 3명의 자손을 낳고 40%의 확률로 4번째 자손을 낳을 수 있다는 뜻이다. 두 종의 출생률이 비슷하면 어느 한 종이 멸종하기까지 오랜 시간이 걸리고 출생율의 차이가 커질수록 출생율이 작은 종이 더 빨리 멸종하는 것을 확인할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
민감도 분석 (Sensitivity Experiments)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
민감도 분석은 시뮬레이션에서 특정한 파라미터나 input에 따라 모델이 어떻게 변하는지 분석하는 것이다. 이 때, 모델은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;확률적인(stochastic)&lt;/b&gt; 특성을 가지기 때문에 같은 파라미터로 시뮬레이션해도 완전히 똑같은 결과가 나오지 않는다. 따라서 각각의 시나리오에 대해 최소 30번 이상 실행하여 평균값을 얻어야 한다. NetLogo에서는 Tools &amp;gt; BehaviorSpace 탭으로 들어가면 여러 조건을 주고 실험할 수 있으며 결과를 엑셀 등으로 저장할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL17.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL16.png&quot; width=&quot;310&quot; height=&quot;310&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
실험결과를 이용해 오른쪽 그림과 같이 boxplot을 그려 분석해볼 수 있다. 빨간색 turtle의 출생률은 2로 고정시키고 파란색 turtle의 출생률을 증가시켰을 때, 빨간색 turtle이 멸종하는 시간이 점점 더 짧아짐을 볼 수 있다.
&lt;br /&gt;&lt;br /&gt;
앞서 살펴본 Flocking 모델에서도 Emergnet behavior를 관찰할 수 있다. 그러나 완전히 발현되기까지 warm-up 단계(대략 400ticks 부터 발현)를 거칠 수도 있다. Emergence를 구체화하기 위해서는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;정량적인 방법 (quantitative measurements)&lt;/b&gt;이 필요하며, 예를 들어 flockmates의 수나 거리를 평균적으로 구해보거나 방향에 대한 표준편차 등을 구해보는 것 등이 있다. 또는 대조적인 시나리오를 비교해보는 방법도 있다. Flocking 모델을 예로 들면, flockmate를 범위 안에 있는 모든 turtle로 정의할지, 가장 가까운 turtle만 정의할지에 따라 결과가 달라진다. 
&lt;br /&gt;&lt;br /&gt;


&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM8/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM8/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Testing Your Program</title>
        <description>&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
Overview of a Simulation Study
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;ol&gt;
&lt;li&gt;시스템 이해하기 (시스템에 관한 사전지식 등)&lt;/li&gt;
&lt;li&gt;목표를 분명히 하기&lt;/li&gt;
&lt;li&gt;모델에 대한 묘사 공식화하기&lt;/li&gt;
&lt;li&gt;모델링 소프트웨어로 변환하기&lt;/li&gt;
&lt;li&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;프로그램 확인하기(verify, debugging)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;모델 확인하기(vaildate)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;실험 디자인하기&lt;/li&gt;
&lt;li&gt;모델 실행하기&lt;/li&gt;
&lt;li&gt;결과에 대해 insight를 얻고 분석하여 문서화하기&lt;/li&gt;
&lt;/ol&gt;

모델을 테스트하는 3단계는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Vaildation&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Verification&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Debugging&lt;/b&gt;이다. Verification은 모델 formulation이 소프트웨어에서 정확하게 실행되는지 확인하는 것이다. 즉, 원하는대로 프로그램이 실행되는지 확실히 하는 것이다. 이 과정에서 실수를 찾고 고치는 노력이 요구되며 모델링의 효율을 높이기 위해 가능한 빨리 테스트를 시작하고 코드를 지속적으로 테스트해야한다. (디버깅도 verification의 한 부분이다.) Vaildation은 모델이 실제 상황을 충분히 잘 반영하고 있는지 확인하는 것이다. ABM에서는 특히 예측되지 않은 결과(Unexpected Result)에 대한 주의가 필요하다. 결과가 새롭고(novel) 중요한지, 모델 디자인은 의심스럽지 않은지, 프로그래밍 실수가 있는지 등을 확인해야한다.  
&lt;br /&gt; &lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-right: 1em;&quot;&gt;
Common Kinds of Errors
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
흔히 발생하는 에러들은 다음과 같다. 
&lt;br /&gt;&lt;br /&gt;
&lt;li type=&quot;circle&quot;&gt;Typographical Errors (타이핑을 잘못한 경우)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Syntax Errors (잘못된 구문)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;isunderstanding Primitives (원래 생각했던대로 정확하게 구현을 못한 경우)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Wrong Display Setting&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Run-Time Errors (프로그램을 실행할 때, 컴퓨터가 다룰 수 없는 무언가가 있는 경우)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt; &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Logic Errors&lt;/b&gt; (잘못된 식, 부정확한 조건 등)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Formulation Errors (가정, 알고리즘, 파라미터 값에 대한 에러, validation issues)&lt;/li&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-right: 1em;&quot;&gt;
Techniques for Debugging and Testing
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
실수를 줄이기 위해서는 Debugging과 Testing 과정이 중요하며 다음과 같은 기법들이 있다.
&lt;br /&gt;&lt;br /&gt;

&lt;li type=&quot;circle&quot;&gt; Syntax Checking (코드 작성시 수시로 syntax를 확인하는 습관을 가지는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Visual Testing (시각적으로 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Print Statement (어떻게 작동하는지 프린트해서 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Spot Tests with Agent Monitors (NetLogo View에 있는 Agent Monitor로 확인하는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Stress Tests (extreme 값을 파라미터나 input으로 넣어 프로그램을 실행하는 것, 평범한 조건에서 숨겨진 에러를 발견할 수도 있다.), 
&lt;li type=&quot;circle&quot;&gt;Test Procedure (중간 output을 만들어 테스트 해보는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Test Programs (특정한 프로그램 아이디어를 테스트하기 위해 짧은 프로그램으로 분리하여 실행하는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Code Reviews (동료들과 리뷰해보는 것, 다른 사람이 확인하면 실수가 발견될 수 있고 코드를 잘 정리하고 이해하기 쉽게 하기위해서)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Statistical Analysis of File OutPut (예상했던대로 모델이 formulation 되었는지 확인하기 위해 모델의 핵심 부분을 file output으로 적어 분석해보는 것)&lt;/li&gt; 
&lt;li type=&quot;circle&quot;&gt;Independent Reimplementation of Submodels (엑셀이나 R, Python 등 다른 플랫폼으로 확인해보는 것)&lt;/li&gt;
&lt;li type=&quot;circle&quot;&gt;Documentation of Tests(사용된 test의 종류, 모델을 실행한 방법과 결과 등을 문서화하는 것)&lt;/li&gt;

&lt;br /&gt;

&lt;/li&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM7/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM7/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - From Animations to Science</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
모델은 그 자체가 목적은 아니다. 관찰된 사실이나 증명된 이론을 사용하여 실제 실험이나 가상의 실험을 수행할 수 있도록 돕는 역할을 한다. 일반적으로 과학적 접근방법의 프로세스는 다음과 같다. 먼저 경험적 연구(Observation/Measurement 등)와 이론적 연구(Ideas/Abstract Principles 등)를 토대로 가설을 세우고 가설을 테스트한다. 만약 가설이 틀렸다면 다시 가설을 세우고 맞을경우 가설을 증명하여 일반적인 법칙으로 받아들인다.
&lt;br /&gt; &lt;br /&gt;
앞서 살펴본 Butterfly model의 경우 나비의 움직임을 시뮬레이션 해볼 수는 있지만, corridors가 언제 어떻게 강하게 발현되는지에 대해서는 설명해주지 않는다. 이 경우 &#39;corridor를 어떻게 묘사해야할까&#39; 라는 의문이 든다. 그렇기 때문에 우리는 분석을 위한 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Quantitative Output&lt;/b&gt;이 필요하다. 파라미터 &lt;i&gt;q&lt;/i&gt; (나비가 가장 높은 위치로 이동할 확률)를 바꾸거나 지형을 바꿈으로써 나비가 움직인 경로의 길이가 어떻게 변화하는지 수량화하는 것도 하나의 방법이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly4.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly3.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;
파라미터 &lt;i&gt;q&lt;/i&gt;에 따라 corridor width가 변하는 것을 볼 수 있다. &lt;i&gt;q&lt;/i&gt;가 1에 가까울수록 나비들의 이동에 대한 무작위성이 적기 때문에 움직임이 직선에 가까워지고 corridor width가 더 작아짐을 볼 수 있다. NetLogo의 plot을 활용하여 시간에 따른 corridor의 변화를 그려볼 수도 있다. 이러한 분석을 Time-series 분석이라고 한다. 
&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM6/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM6/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Butterfly Hilltopping Model</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
모델 설명
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
이번에는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Butterfly Hilltopping Model&lt;/b&gt;의 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;ODD&lt;/b&gt;를 설명하고자 한다. 일단 ODD란 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;O&lt;/b&gt;verview, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;D&lt;/b&gt;esign Concepts, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;D&lt;/b&gt;etails의 약어이다. Overview는 이 모델이 무엇인지, 어떻게 디자인 되었는지 설명한다. (Purpose, Entities, State Variables, Scales, Process Overview, Scheduling 등) Design Concepts는 ABM의 필수적인 특징을 묘사하고 디자인 컨셉을 설명한다. Details는 완전한 묘사를 위해 필요한 세부 사항을 포함한다. (Initialization, Input Data, Submodels 등)
&lt;br /&gt;&lt;br /&gt;
많은 동물들이 여러 목적(mating 등)을 위해 home location을 떠나 다른 곳으로 이동한다. 특히 나비들은 landscape에 반응하여 움직이는데 이러한 움직임을 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Corridors&lt;/b&gt; 라고 불리는 경로로 연결시킬 수 있다. 이는 나비 떼가 짝을 만나기 위해 hilltop을 향해 이동하는 모양이 통로처럼 보여 붙여진 이름이다. Butterfly Hilltopping 모델은 가상의 corridors에 대해 설명하기 위해 디자인되었다. 즉, 나비들이 hilltop을 향해 움직이는 행동이 조건으로 주어졌을 때, landscape의 지형이 가상의 corridors의 발현(emergence)을 이끄는지 시뮬레이션 해보는 것이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly2.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/butterfly.gif&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
이 모델은 나비와 지형 두 가지 개체(entity)를 가지고 지형마다 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;고도(elevation)&lt;/b&gt;라는 상태 변수(state variable)를 가진다. 나비들은 각자의 위치에 의해 특정되고 시뮬레이션은 1000번째 스텝까지만 지속한다. 이 모델의 프로세스는 나비들의 움직임이고 스텝 한번에 한번 움직이며 나비끼리 상호작용은 없기 때문에 움직임의 순서는 중요하지 않다. 그러나 나비들이 위를 향해 움직일 때 항상 직진으로 움직이지 않기 때문에 나비가 움직이는 방향에 대한 randomness를 추가해준다. 여기서는 파라미터 &lt;i&gt;q&lt;/i&gt;로 이를 조절한다. 그리고 가상의 corridors를 관찰하기 위해 구체적인 corridor width(시작점부터 꼭대기까지 나비가 날아간 경로의 길이)를 정의한다. 지형의 고도는 인공적으로 만들어서 적용할 수도 있고(왼쪽 그림), 실제 연구 자료의 데이터를 사용(오른쪽 그림)할 수도 있다. 

&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM5/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM5/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Getting Started with NetLogo</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
기초 연습 (Elementary Exercises)
&lt;/span&gt;
&lt;br /&gt;
&lt;ol&gt;
&lt;li&gt;전체 view 화면을 파란색으로 바꾸기 : &lt;code&gt;ask patches [set pcolor blue]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 위치(0,0) patch를 빨간색으로 바꾸기 : &lt;code&gt;ask patch 0 0 [set pcolor red]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 위치(0,5)에 turtle 1개 만들기 : &lt;code&gt;create-turtles 1 [ setxy 0 5 ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;모든 turtle들을 1만큼 앞으로 움직이기 : &lt;code&gt;ask turtles [fd 1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;모든 turtle들의 방향(heading) 우측으로 바꾸기 : &lt;code&gt;ask turtles [set heading 90]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;turtle 1의 색깔, 사이즈, 모양 바꾸기 : &lt;code&gt;ask turtle 1 [set size 5 set shape &quot;cat&quot; set color yellow]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;초기화하기 : &lt;code&gt;clear-all&lt;/code&gt;또는 &lt;code&gt;ca&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;turtle이 움직인 경로 나타내기 : &lt;code&gt;pen-down&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL11.png&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL10.png&quot; width=&quot;270&quot; height=&quot;300&quot; /&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
이를 위와 같이 변수값은 global variable로 지정하여 interface에서 여러 값을 변환할 수 있게 할 수 있다. 또한 아래와 같이 위, 아래, 왼쪽, 오른쪽으로 turtle을 움직일 수 있고 주황색 부분은 통과할 수 없게 만들 수 있다. 
&lt;br /&gt; &lt;br /&gt;
&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL13.png&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL12.png&quot; width=&quot;270&quot; height=&quot;300&quot; /&gt;
&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.3em;&quot;&gt;
Neighbors
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
NetLogo에서 turtle이나 patch의 이웃은 다음과 같이 표현된다. neighbors를 사용하면 주변에 모든 patch가 선택되고 neighbors4를 사용하면 상하좌우 4개의 patch만 선택된다.&lt;br /&gt; &lt;br /&gt;
&lt;p style=&quot;text-align:center; &quot;&gt;
&lt;code&gt;ask turtle 0 [show count neighbors with [pcolor = green]]&lt;/code&gt;
&lt;br /&gt; 
&lt;code&gt;ask patch 0 0 [show count neighbors4 with [pcolor = green]]&lt;/code&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/NL14.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;
&lt;/p&gt;


&lt;/div&gt;
</description>
        <pubDate>Tue, 07 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM4/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM4/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>Agent Based Modeling - Compelx Systems and Agent Based Modeling</title>
        <description>&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
시스템 (SYSTEM)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;시스템&lt;/b&gt;은 어떤 목적을 이루기 위해 함께 상호작용하고 행동하는 요소들의 집합이다. 시스템을 모델링하는 두 가지 측면이 있는데 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Aggregate View&lt;/b&gt; (Top-down approach)와 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Constituent View&lt;/b&gt; (Bottom-up approach)이다. Aggregate View는 target system의 프로세스, 내부 관계, 파라미터 등을 안다고 가정하는 것이고, 개인의 자유도는 보통 무시되며 (homogeneity) pre-determinded 구조를 가진다. Constituent View는 통합적인 것보다 각 요소의 성질이나 행동 (action, decision pattern 등)에 초점을 맞추며 진화하는 (evolving) 구조를 가진다.  
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
복잡한 시스템 (COMPLEX SYSTEMS)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Complex systems&lt;/b&gt;은 다양한 분야의 문제에 대한 접근방법을 포괄하는 광범위한 용어로 사용되므로 어느 한 가지로 정의하기 힘들다. 어떤 요소의 행동으로 단순히 complex systems의 행동을 예측하기는 힘들고 전체 시스템을 부분으로 나누어 각각을 이해하는 것도 옳지 않다. 즉, 단순하게 1+1은 2가 아니라고 생각하면 쉽게 연상할 수 있다. Complex systems는 중심적인 제어장치와 단순한 운영 규칙이 없는 거대한 네트워크이며 복잡한 집단 행동, 정교한 정보처리, 학습을 통한 적응이 이루어진다. 또한, nontrivial emergent 또는 자기 조직적 행동을 나타낼 수도 있다. 예를 들어 각 개인의 거래자가 시스템이라면 그 거래자들이 모인 마켓의 수요와 공급을 complex systems로 볼 수 있다. 또는 뉴런이 모인 뇌를 complex systems로도 볼 수 있으며 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;채찍효과(Bullwhip Effect)&lt;/b&gt;도 예시로 들 수 있다. 
&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL8.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 2em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/NL9.png&quot; width=&quot;280&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
채찍효과란 고객주문 정보가 상류로 전달되는 과정에서 정보가 왜곡되고 확대되는 현상을 말한다. 말그대로 채찍질하는 사람을 생각하면 이해하기 쉽다. 처음에는 채찍의 폭이 좁지만 갈수록 커지는 것과 같아 붙여진 이름이다. Complex systems에서는 초기 조건의 작은 차이(반올림에 따른 값의 차이 등)가 완전히 다른 결과를 초래할 수 있다. 마치 나비효과처럼 말이다. 
&lt;br /&gt;&lt;br /&gt;

Complex systems는 5가지 특성을 가지는데 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Non-linearity&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Interconnectedness&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Feedbacks&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Delays&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Heterogeneity&lt;/b&gt;이다. Input은 선형적인 방식으로 output에 영향을 미치는 것은 아니며 각각은 연결되어 있고 다른 결정에 영향을 미친다. 그러므로 각각을 하나씩 분리함으로써 문제를 풀 수는 없다. 또한, 시스템의 output에 따라 행동이 변할 수 있고, output이 input에 영향을 끼치기 위해 지연될 수 있으며, 각각은 여러가지 다양한 종류들로 이루어진다. Agent Based Model, System Dynamics, Network theory(complex networks) 모두 complex systems modeling이다.

&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
에이전트 기반 모델 (ABM)
&lt;/span&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

Complex systems에서 발생한 문제에 대한 답으로 단순한 모델은 더이상 충분하지 않다. &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;ABM&lt;/b&gt; (Agent Based Modeling)은 그에 대한 해답을 주는 주된 방법 중 하나이며, 시스템 전체에 미치는 영향을 평가하기 위한 목적으로 자율적인 에이전트의 행동과 상호작용을 시뮬레이션하는 계산 모델의 일종이다. 또한, 복잡한 현상의 출현을 re-create하고 예측하면서 동시다발적인 현상과 다수의 agent들의 상호작용을 시뮬레이션하는 microscale 모델의 일종이다. 
&lt;br /&gt;&lt;br /&gt;
여기서 Agent는 특정한 성질(property)이나 상태(state) 또는 행동(action)을 지닌 자율적이고 계산적인 객체를 의미하며 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Emergence&lt;/b&gt;는 다수의 분포된 element들의 상호작용을 통해 발생한 새롭고 일관적인 구조, 패턴, 성질을 의미한다. Emergent 구조는 element의 성질로 부터 단독으로 추론될 수 없고 element의 상호작용을 통해 생긴다. 또한, 어떠한 제어 요소없이 자발적으로 발생되기 때문에 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;self-organizes&lt;/b&gt;라고 할 수 있다. 에이전트 기반 모델링의 핵심은 어떤 현상에 대한 간단한 규칙을 찾아 emergence를 활용하는 것이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/v_shape.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/fish-flocking.jpg&quot; width=&quot;310&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
Emergence의 예시로 자연현상에서 모티브를 받은 건축물, Fish Flocking (물고기들이 떼지어 헤엄치는 것), Bird Flocking (새들이 떼지어 날아다니는 것), 기러기떼가 V자 형태로 날아가는 것 등을 들 수 있다. NetLogo 모델의 example로 Flocking.nlogo 파일이 있으므로 참고해도 좋다. 이 모델은 새들이 떼지어 다니는 행동을 시뮬레이션하기 위해 Craig Reynolds가 1986년에 고안해낸 모델이다.
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/flocking.gif&quot; width=&quot;250&quot; height=&quot;250&quot; /&gt;
&lt;/p&gt;

이 모델에서는 새들의 움직임을 시뮬레이션하기 위해 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Separate&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Cohere&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Align&lt;/b&gt;의 특징을 가진다고 가정한다. Separate는 다른 모든 객체들과 최소 거리를 유지해야함을 뜻하고 Cohere는 flockmate를 향해 움직여야함을, Align은 flockmate와 같은 방향으로 움직여야함을 뜻한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-weight:700; font-size:1.3em; margin-left: 0.8em; margin-right: 1em;&quot;&gt;
ABM 장점 및 단점 
&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
ABM은 복잡한 현상을 이해하기 쉽게 시각적으로 표현해주고 상호작용하는 요소들 사이의 연결을 잘 나태내어주는 장점을 가진다. 또한 귀납적(induction), 연역적(deduction)방법을 통합한 방법을 사용하여 알려진 전제들로 일반적인 이론을 만들기 위한 특정한 데이터 집합을 만들 수 있다. 우리가 알려진 하나의 전제를 알고 있을 경우 통합적인 패턴을 결정하는 것은 어렵지만 ABM은 이를 이해하기 쉽게 해주고, 반대로 통합적인 패턴을 알고 있을 경우에는 규칙을 제안하여 그 현상이 만들어지는지 확인함으로써 각각의 전제를 알 수 있도록 해준다. 
&lt;br /&gt;&lt;br /&gt;
그러나 ABM의 계산적인 모델은 예측가능한 결과를 주로 만들고 구체적인 상황에 근사적으로 맞춰져있으며 확실하지 않다. 또한, 계산 모델을 수정하고 이해하기가 쉽지 않다는 단점이 있다.
&lt;/div&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ABM3/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ABM3/</guid>
        
        
        <category>수업</category>
        
      </item>
    
  </channel>
</rss>
