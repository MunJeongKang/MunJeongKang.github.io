<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>코딩새내기 일상일지</title>
    <description>github blog</description>
    <link>http://munjeongkang.github.io/</link>
    <atom:link href="http://munjeongkang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 21 Sep 2020 08:58:58 +0900</pubDate>
    <lastBuildDate>Mon, 21 Sep 2020 08:58:58 +0900</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>CO@Work2020 - LP &amp; Polyhedral Theory</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;embed src=&quot;/CO@WORK/Berthold_Theory_I.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;425px&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;!-- &lt;span style = &quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Fundamentals about Mathematical Optimization 
&lt;/span&gt;
&lt;br&gt;&lt;br&gt;
다음과 같은 IP(Integer program)를 생각해보자.  --&gt;


 &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%;&quot;&gt;
강의 자료 영상 :
&lt;/span&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=svG_zFSGZRY&amp;amp;list=PLYWmzh0Y6EObSVICd9OUamulR2SZ4NXmi&amp;amp;index=3&quot;&gt; LP &amp;amp; Polyhedral Theory &lt;/a&gt;&lt;/p&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;

&lt;!-- $$
\begin{aligned}
    \text{(IP)} \quad &amp;z=\max cx \\
    &amp;Ax \le b \\
    &amp;Dx \le d  \\
    &amp;x \in Z^n_+
\end{aligned}
$$

어떤 제약조건만 있는 IP는 쉽게 풀린다는 관점에서 $Ax \le b$ 식을 &quot;nice&quot;하다고 가정해보자. 그러면 복잡한(complicating) 제약식 $Dx \le d$만 없다면 원래 IP 문제를 푸는 것 보다 relaxation이 더 쉬워진다. 많은 문제들이 이처럼 나이스한 제약과 복잡한 제약을 동시에 갖고 있는데, &lt;b style = &quot;color:#d7385e;font-size:1.2&quot;&gt;복잡한 제약을 없앨 수 있다면 쉽게 문제를 풀 수도 있을 것&lt;/b&gt;이다. 예를 들어 TSP (traveling salesman problem)의 connectivity 제약식, UFL(uncapacitated facility location)의 client demand 제약식 등 복잡한 제약을 없앨 수 있다면 말이다. 그러나 그냥 없애버리면 중요한 제약식이 전부 무시되기 때문에 relaxation의 bound가 매우 좋지 않으므로 &lt;b style = &quot;color:#d7385e;font-size:1.2&quot;&gt;Lagrangian relaxation&lt;/b&gt;을 사용하고자 한다. 

&lt;br&gt;&lt;br&gt;
IP 문제를 좀더 간단하게 일반적인 폼 (general form)으로 바꿔보자. 

$$
\begin{aligned}
    &amp;z=\max cx \\
    &amp;Dx \le d  \\
    &amp;x \in X
\end{aligned}
$$

여기서 $Dx \le d $는 $m$개의 복잡한 제약식이다. 

&lt;br&gt;&lt;br&gt;

어떤 값 $u = (u_1, ... , u_m) \ge 0$ 에 대해 다음과 같이 IP의 relaxation을 정의하자. 

$$
\begin{aligned}
    \text{(IP(u))} \quad &amp;z(u)=\max cx + u(d-Dx)\\
    &amp;x \in X
\end{aligned}
$$

IP($u$)는 $\{x : Dx \le d, x \in X\} \subseteq X $ 이므로 &lt;b style = &quot;color:#d7385e;font-size:1.2&quot;&gt;feasibel region&lt;/b&gt;은 같거나 크고, $u \ge 0$ 이고 모든 $x \in X$에 대해 $(d-Dx) \ge 0$이므로 &lt;b style = &quot;color:#d7385e;font-size:1.2&quot;&gt;목적값(objective value)&lt;/b&gt; 또한 원래 IP 문제보다 같거나 크다. 

&lt;br&gt;&lt;br&gt;

IP($u$)에서 복잡한 제약식이 목적함수의 penalty term인 $u(d-Dx)$으로 추가됨으로써 다루어지는 것을 볼 수 있다. 이 때 $u$ 를 $Dx \le d$ 제약에 대한 &lt;i&gt;&lt;b style = &quot;color:#d7385e; &quot;&gt;Lagrange multiplier&lt;/b&gt;&lt;/i&gt; (&lt;i&gt;price&lt;/i&gt;, &lt;i&gt;dual variable&lt;/i&gt;) 라고 한다. 
&lt;br&gt;&lt;br&gt;

따라서 IP($u$)를 파라미터 $u$를 가진 IP의 &lt;i&gt;Lagrangian relaxation (subproblem)&lt;/i&gt;이라 부른다. IP($u$)는 IP의 relaxation이기 때문에 $z(u) \ge z$이고 IP의 최적값(opmial value)의 upper bound를 얻을 수 있다. 가장 좋은 upper bound를 찾기 위해 &lt;i&gt;&lt;b style = &quot;color:#d7385e;font-size:1.2&quot;&gt;Lagrangian Dual Problem&lt;/b&gt;&lt;/i&gt;을 푼다. 
&lt;br&gt;&lt;br&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/max_relaxation_bound.png&quot; width=&quot;350&quot; height=&quot;170&quot;&gt;
&lt;/p&gt;
Lagrangian Dual Problem은 다음과 같이 정의한다. 

$$
\begin{aligned}
    \text{(LD)} \quad &amp;w_{LD}=\min \{z(u) : u \ge 0 \} 
\end{aligned}
$$

Lagrangian relaxation을 풀어 IP의 최적 솔루션을 찾을 수도 있다.
&lt;br&gt;&lt;br&gt;

&lt;div style = &quot;border: 0px solid red; text-align: left; margin: 0 auto; width:45% &quot;&gt;
 IF $u \ge 0$, &lt;br&gt;
1. $x(u)$는 IP($u$)의 &lt;i&gt;optimal solution&lt;/i&gt;이고 &lt;br&gt;
2. $D(x) \le d$ 이고 &lt;br&gt;  
3. $u_i &gt; 0$일 경우, $(Dx(u))_i = d_i$&lt;br&gt;
THEN $x(u)$는 IP의 optimal이다.
&lt;/div&gt;
&lt;br&gt;
1에 의해 $w_{LD} \le z(u)$이고, 3에 의해 $cx(u)+u(d-Dx(u)) = cx(u)$이다. 2에 의해 $x(u)$는 IP에서 feasible이고 따라서 $cx(u) \le z$ 이다. 그러므로 $w_{LD} \le z(u) = cx(u) \le z$이고 equality 제약으로 인해 $w_{LD} \ge z$이므로 $x(u)$는 IP에서 optimal이다. 
&lt;br&gt;&lt;br&gt;
&lt;span style = &quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Application - UFL
&lt;/span&gt;
&lt;br&gt;&lt;br&gt;
UFL 문제에 이를 적용해 보자. 먼저, strong formulation으로 시작한다. 
$$
\begin{aligned}
    \text{(IP)} \quad z=\max &amp;\sum_{i \in M} \sum_{j \in N} c_{ij}x_{ij} - \sum_{j \in N} f_j y_j \\
    &amp;\sum_{j \in N} x_{ij} = 1 \quad \forall i \in M  \\
    &amp;x_{ij}-y_j \le 0 \quad \forall i \in M, j \in N \\ 
    &amp;x \in R^{|M|\times|N|}, y \in B^{|N|}
\end{aligned}
$$

demand 제약식을 dualizing한다.
$$
\begin{aligned}
    \text{(IP($u$))} \quad z=\max &amp;\sum_{i \in M} \sum_{j \in N} (c_{ij}-u_i)x_{ij} - \sum_{j \in N} f_j y_j + \sum_{i \in M}u_i \\
    &amp;x_{ij}-y_j \le 0 \quad \forall i \in M, j \in N \\ 
    &amp;x \in R^{|M|\times|N|}, y \in B^{|N|}
\end{aligned}
$$
이는 각 location에 대한 subproblem으로 갈라진다. 
$$
\begin{aligned}
    \text{(IP}_j(u)) \quad z_j(u)=\max &amp;\sum_{i \in M} (c_{ij}-u_i)x_{ij} - f_j y_j \\
    &amp;x_{ij}-y_j \le 0 \quad \forall i \in M \\ 
    &amp;x_{ij} \ge 0 \quad \forall i \in M, y_i \in B^1
\end{aligned}
$$

따라서 $IP_j(u)$이면 $z(u) = \sum_{j \in N} z_j(u) + \sum_{i \in M} u_i$이다. 
만약 $y_j = 0$이면 모든 $i$에 대해 $x_{ij} = 0$이고 목적값은 0이 된다. 만약 $y_j=1$이면 profitable한 모든 고객은 서비스를 받으므로 $c_{ij}-u_i &gt;0$이다. 따라서 $z_j(u) = \max \{0, \sum_{i \in M} \max [c_{ij}-u_i, 0]-f_j\}$이다.
&lt;br&gt;&lt;br&gt;
&lt;span style = &quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
UFL Example
&lt;/span&gt;

&lt;br&gt;&lt;br&gt;
이와 관련된 간단한 예시를 들어보자. $m = 6$인 clients와 $n=5$인 potential locations가 있고 fixed location cost $f = (2,4,5,3,3)$이고 client-location profit matrix($c_{ij}$)는 왼쪽과 같다고 하자. $u=(5,6,3,2,5,4)$라 하면 ($c_{ij}-u_i$)를 오른쪽과 같이 나타낼 수 있다. 
&lt;br&gt;&lt;br&gt;

&lt;div style=&quot;display: inline-block; margin-left: 0.5em; margin-right: 0.5em; &quot;&gt;
&lt;img src=&quot;/images/post_img/ex1.png&quot; width=&quot;250&quot; height=&quot;150&quot;  &gt;
&lt;/div&gt;
&lt;div style=&quot;display: inline-block; margin-right: 0.5em; &quot;&gt;
&lt;img src=&quot;/images/post_img/ex2.png&quot; width=&quot;300&quot; height=&quot;150&quot; &gt;
&lt;/div&gt;
&lt;br&gt;
모든 $j = 2$에 대해 $y_2=0$이면 0의 값을 얻고 $y_2=1$이면 $x_{22}=1$, $x_{52}=1$로 설정하여 $y_2=1$인 net profit이 7-4 = 3이 된다. 그러므로 $z_2(u)=3$을 주는 $y_2=1$로 설정하는 것이 optimal 이다. 각 depot에 대해 비슷한 계산을 수행하면 IP($u$)의 optimal solution은 $y_1=y_3=y_5=0$, $y_2=x_{22}=x_{52}=1$, $y_4 = x_{64}=1$로 세팅하면 $z(u) = 3+1+\sum_{i \in M} u_i = 29$ 이다. 

&lt;br&gt;&lt;br&gt;
&lt;hr&gt;
 --&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;
</description>
        <pubDate>Mon, 21 Sep 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/CO@WORK/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/CO@WORK/</guid>
        
        
        <category>최적화</category>
        
      </item>
    
      <item>
        <title>논문리뷰 - The flying sidekick traveling salesman problem: Optimization of drone-assisted parcel delivery</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Abstract &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
Once limited to the military domain, unmanned aerial vehicles are now poised to gain widespread adoption in the commercial sector. One such application is to deploy these air-craft, also known as drones, for last-mile delivery in logistics operations. While significant research efforts are underway to improve the technology required to enable delivery by drone, less attention has been focused on the operational challenges associated with lever- aging this technology. This paper provides two mathematical programming models aimed at optimal routing and scheduling of unmanned aircraft, and delivery trucks, in this new paradigm of parcel delivery. In particular, a unique variant of the classical vehicle routing problem is introduced, motivated by a scenario in which an unmanned aerial vehicle works in collaboration with a traditional delivery truck to distribute parcels. We present mixed integer linear programming formulations for two delivery-by-drone problems, along with two simple, yet effective, heuristic solution approaches to solve problems of practical size. Solutions to these problems will facilitate the adoption of unmanned aircraft for last-mile delivery. Such a delivery system is expected to provide faster receipt of customer orders at less cost to the distributor and with reduced environmental impacts. A numerical analysis demonstrates the effectiveness of the heuristics and investigates the tradeoffs between using drones with faster flight speeds versus longer endurance.&lt;br /&gt;&lt;br /&gt;
&lt;em&gt;Keywords : Unmanned aerial vehicle, Vehicle routing problem, Traveling salesman problem, Logistics,Integer programming, Heuristics &lt;/em&gt; 
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Summary
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

최근 물류 분야에서 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;드론을 활용한 배송&lt;/b&gt;에 관한 연구가 많이 이루어지고 있다. 특히, 드론을 통한 배송은 라스트 마일 문제를 해결하는 좋은 방안으로 제시되고 있다. 그러나 드론과 관련된 기술적 문제를 해결하기 위한 연구는 많이 이루어지는 반면 운영상의 문제를 해결하는 연구는 부족하다. 따라서 본 논문에서는 FSTSP와 PDSTSP에 대한 formulation을 제시하고 이에 대한 heuristic 방법을 제시한다. &lt;br /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%;&quot;&gt;
논문 관련 발표 자료 : 
&lt;/span&gt;
&lt;a href=&quot;/seminar/200924_FSTSP.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Cite
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; font-family: Times New Roman; &quot;&gt;
Murray, C. C., &amp;amp; Chu, A. G. (2015). The flying sidekick traveling salesman problem: Optimization of drone-assisted parcel delivery. &lt;i&gt;Transportation Research Part C: Emerging Technologies&lt;/i&gt;, 54, 86-109.
&lt;/span&gt;
&lt;span style=&quot;font-weight:400; font-size:1.0em;&quot;&gt;
&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0968090X15000844?casa_token=SHPJrtqlfuQAAAAA:4FG_RCO7phVfDEe0RjpSLv06nr4N9PyHXXLW5YbjXncUvzalS-8krXPf2K8lTmAv11MKCCQ-Gw&quot;&gt; 논문 링크 &lt;/a&gt;
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;
</description>
        <pubDate>Fri, 18 Sep 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/%E1%84%82%E1%85%A9%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%87%E1%85%B25/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/%E1%84%82%E1%85%A9%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%87%E1%85%B25/</guid>
        
        
        <category>논문리뷰</category>
        
      </item>
    
      <item>
        <title>논문리뷰 - Vehicle Routing Problem with elementary shortest path based column generation</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Abstract &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
The usual column generation model for a Vehicle Routing Problem involves an elementary shortest-path sub- problem. The worst-case complexity of the known algorithms for this problem being too high, the elementary-path constraint is usually relaxed. Indeed, as each customer must be visited exactly once, the two problems with and without the elementary-path constraint have the same optimal integer solutions. In this article, we propose one theoretical and several practical improvements to the algorithm for elementary paths. We obtain better lower bounds and pruning of the search tree, and these improvements allowed us to find an exact solution to 17 instances of the Solomon benchmark suite which were previously open.&lt;br /&gt;&lt;br /&gt;
&lt;em&gt;Keywords : Vehicle routing; Branch-and-Price; Elementary shortest path; &lt;/em&gt; 
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Summary
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

VRP에서 보통 column generation은 elementary shortest-path를 subproblem으로 포함한다. 이 논문에서는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;elementary path에 대한 알고리즘 개선&lt;/b&gt;을 제안한다. 더 좋은 lower bound 얻고 search tree를 pruning하여 솔로몬 데이터의 17개 인스턴스에 대한 exact solution을 찾았다.
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;본문 내용
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify;&quot;&gt;

이 논문에서는 Vehicle Routing Problem with Time Windows (VRPTW)를 다룬다. VRP는 exact method인 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;column generation&lt;/b&gt;을 사용하여 optimal solution을 찾을 수 있다. original linear program은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Dantzig-Wolfe decomposition&lt;/b&gt;을 통해 linear restricted master problem과 pricing subproblem으로 나뉜다. 마스터 문제는 이진 변수를 가지는 partitioning problem이 되고 pricing subproblem은 새로운 column 생성에 대한 제한된 최단 경로 문제가 된다. 
&lt;br /&gt;&lt;br /&gt;
경로에 cycle이 존재하는 Shortest Path with Resource Constraints and Time Windows (SPRCTW) column generation 모델의 optimal integer solution은 elementary routes만을 포함한다. ESPRCTW가 NP-hard인 반면에 SPRCTW는 pseudo-polynomial 알고리즘을 사용할 수 있기 때문에 이를 활용한다. 이 논문에서는 relaxed restricted master problem로 얻은 더 좋은 lower bound와 cycle 제약을 고려한 영향을 줄이기 위한 기술들을 제시한다. 
&lt;br /&gt;&lt;br /&gt;
여기서는 두 가지 VRP 모델을 소개한다. 각각은 VRP with TIme Windows와 최대 용량 $C_k$를 가지는 $K$개의 차량이 있는 문제이다. $N$개의 노드가 방문되어야하고 각 노드 $i$에서 quantity $q_i$가 배송되어야만 한다. 각 노드는 $[a_i,b_i]$로 정의된 time window를 가지며 $A$는 arc 집합을 나타내고 $d$는 각 arc에 대한 거리를 나타낸다. 노드 0과 $N+1$은 dummy 노드 즉, depot를 나타낸다. 목적함수는 $K$개의 차량이 모든 노드에 quantity를 배송하기 위한 최소 거리의 경로 집합를 찾는 것이다.
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
MIP model
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
$x_{ijk}$는 차량 $k$가 arc $(i,j)$ 사용에 대한 이진변수를 나타내고 $s_{ik}$는 차량 $k$가 노드 i에 도착하는 시간을 나타낸다. 제약식은 routes가 valid path를 갖도록 해준다. (모든 차량이 용량을 넘지않고 각 노드가 정확히 한번만 커버되는 것)

&lt;br /&gt;&lt;br /&gt;

$$
\begin{align}
\min \quad &amp;amp; \sum_{k=1}^{K} \sum_{(i, j) \in A} d(i, j) x_{i j k}, \\ 
&amp;amp; \sum_{j \in \delta^{+}(0)} x_{0 j k}=1 \quad \forall k \in\{1, \ldots, K\}, \\ 
&amp;amp; \sum_{i \in \delta^{-}(j)} x_{i j k}-\sum_{i \in \delta^{+}(j)} x_{j i k}=0 \quad \forall k \in\{1, \ldots, K\}, \quad \forall j \in\{1, \ldots, N\}, \\ 
&amp;amp; \sum_{i \in \delta^{-}(N+1)} x_{i, N+1, k}=1 \quad \forall k \in\{1, \ldots, K\}, \\ 
&amp;amp; \sum_{i \in S} \sum_{j \in S, j \neq i} x_{i j k} \leqslant|S|-1 \quad \forall k \in\{1, \ldots, K\}, \quad \forall S \subset X ,  1&amp;lt;|S|&amp;lt; N, \\ 
&amp;amp; \sum_{k=1}^{K} \sum_{j \in \delta^{+}(i)} x_{i j k}=1 \quad \forall i \in\{1, \ldots, N\}, \\ &amp;amp; \sum_{i=1}^{N} q_{i} \sum_{j \in \delta^{+}(i)} x_{i j k} \leqslant C_{k} \quad \forall k \in\{1, \ldots, K\}, \\ 
&amp;amp; s_{i k}+d(i, j)-K\left(1-x_{i j k}\right) \leqslant s_{j k} \quad \forall(i, j) \in A, \quad \forall k \in\{1, \ldots, K\}, \\ 
&amp;amp; \quad \quad \quad a_{i} \leqslant s_{i k} \leqslant b_{i} \quad \forall i \in\{1, \ldots, N\}, \quad \forall k \in\{1, \ldots, K\}, \\
&amp;amp; \quad \quad \quad x_{ijk} \in \{0,1\} \quad \forall k \in \{1, \ldots, K\}, \quad \forall (i,j) \in A.
\end{align}
$$
&lt;br /&gt;
목적함수(1)는 사용하는 arc의 거리 총합을 최소화하는 것이다. 제약식(2)-(4)는 차량 $k$의 flow를 나타내고 제약식(5)는 subtour를 제거해준다. 제약식(6)은 각 노드가 최대 한개의 차량에 의해 방문되어야함을 뜻하고 제약식(7)은 차량의 용량을 넘지않아야함을 뜻한다. 제약식(8)과 (9)는 time windows를 정의한다. 이 때 subtour 제약식의 수가 exponential이므로 Branch-and-Cut을 사용하여 dynamically 추가해준다. 

&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Dantzig-Wolfe decomposition
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
위에서 정의한 MIP 모델에 Dantzig-Wolfe decomposition이 적용된다. 주어진 $k$에 대한 제약식(2)-(5)와 (7)에 해당하는 행렬 $B_k$를 고려한다. $B_k$로 정의된 polytope은 차량 $k$에 대한 valid path의 extreme points 집합 $\Omega_k$를 허용한다. 따라서 그 포인트 중 하나를 path들의 linear combination으로 쓸 수 있다. 이를 위해 극점 $\lambda^p_k$에 해당하는 path에 속하면 1 아니면 0인 계수 $x^p_{ijk}$를 사용한다. 따라서 $k \in \{1,\ldots,K\}$에 대해 솔루션 $x_{ijk}$를 다음과 같이 나타낼 수 있다. 
&lt;br /&gt;&lt;br /&gt;
$$
\begin{aligned}
&amp;amp;x_{ijk} = \sum_{p \in \Omega_k} x^p_{ijk} \lambda^p_k \quad \forall (i,j) \in A, \\
&amp;amp;\sum_{p \in \Omega_k} \lambda^p_k  = 1 \quad \forall k \in \{1,\ldots,K\}, \\
&amp;amp;\lambda^p_k \geqslant 0 \quad \forall p \in \Omega_k.
\end{aligned}
$$
&lt;br /&gt;
차량 $k$에 대한 route $p$의 cost를 $c^p_k$로 정의힌다. 또한 양수인 정수 $a^p_{ik}$는 route $p$에 대해 차량 $k$가 노드 $i$를 방문한 횟수를 나타낸다. 
&lt;br /&gt;&lt;br /&gt;
$$
\begin{aligned}
&amp;amp;c^p_k = \sum_{(i,j) \in A} c(i,j)x^p_{ijk} \quad \forall k \in \{1,\ldots,K\}, \quad \forall p \in \Omega_k, \\
&amp;amp;a^p_{ik} = \sum_{j \in \delta^+(i)} x^p_{ijk} \quad \forall i \in \{1,\ldots,\}N \quad \forall k \in \{1,\ldots,\}K, \quad \forall p \in \Omega_k, 
\end{aligned}
$$
&lt;br /&gt;
이러한 표현들을 원래 모델로 대체한다면 다음과 같은 decomposed model을 얻는다. 
&lt;br /&gt;&lt;br /&gt;
$$
\begin{aligned}
\min \quad &amp;amp; \sum_{k=1}^{K} \sum_{p \in \Omega_k} c^p_k \lambda^p_k, \\ 
&amp;amp;\sum_{k=1}^{K} \sum_{p \in \Omega_k} a^p_{ik} \lambda^p_k  = 1 \quad \forall i \in \{1,\ldots,N\}, \\
&amp;amp;\sum_{p \in \Omega_k} \lambda^p_k = 1 \quad \forall k \in \{1,\ldots,K\}, \\
&amp;amp;\lambda^p_k \geqslant 0 \quad \forall k \in \{1,\ldots,K\} \forall p \in \Omega_k.
\end{aligned}
$$
&lt;br /&gt;
capacity, subtour elimination, time window 제약은 extreme point path의 validity를 정의하는 subproblems로 이동된다. 
&lt;br /&gt;&lt;br /&gt;
$$
\begin{aligned}
\min \quad &amp;amp; \sum_{(i, j) \in A} d(i, j) x_{i j}, \\ 
&amp;amp; \sum_{j \in \delta^{+}(0)} x_{0 j }=1 , \\ 
&amp;amp; \sum_{i \in \delta^{-}(j)} x_{i j}-\sum_{i \in \delta^{+}(j)} x_{j i}=0 \quad \forall j \in\{1, \ldots, N\}, \\ 
&amp;amp; \sum_{i \in \delta^{-}(N+1)} x_{i, N+1}=1 , \\ 
&amp;amp; \sum_{i \in S} \sum_{j \in S, j \neq i} x_{i j} \leqslant|S|-1 \quad \forall S \subset X ,  1&amp;lt;|S|&amp;lt; N, \\ 
&amp;amp; \sum_{i=1}^{N} q_{i} \sum_{j \in \delta^{+}(i)} x_{i j } \leqslant C_{k}, \\ 
&amp;amp; s_{i }+d(i, j)-K\left(1-x_{i j }\right) \leqslant s_{j } \quad \forall(i, j) \in A, \\ 
&amp;amp; \quad \quad \quad a_{i} \leqslant s_{i} \leqslant b_{i} \quad \forall i \in\{1, \ldots, N\},  \\
&amp;amp; \quad \quad \quad x_{ij} \in \{0,1\} \quad \forall (i,j) \in A.
\end{aligned}
$$

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Identical vehicles
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
차량이 동일할 때 (총 용량이 같을 때) 모델의 일부를 다음과 같이 바꿀 수 있다. 
$$
\begin{aligned}
\lambda^p = \sum^K_{k=1} \lambda^p_k \quad \forall p \in \Omega = \bigcup^K_{k=1} \Omega_k
\end{aligned}
$$
그러면 다음과 같은 모델을 얻을 수 있다. 
$$
\begin{align}
\min \quad &amp;amp; \sum_{p \in \Omega} c^p \lambda^p, \notag \\ 
&amp;amp;\sum_{p \in \Omega} a^p_{i} \lambda^p  = 1 \quad \forall i \in \{1,\ldots,N\}, \\
&amp;amp;\sum_{p \in \Omega} \lambda^p = K, \notag \\
&amp;amp; \quad \quad \lambda^p \geqslant 0 \quad \forall p \in \Omega.
\end{align}
$$
&lt;br /&gt;
decomposed model은 가능한 path 변수를 매우 많이 포함한다. 만약 $N$이 노드의 수라면 이론적으로 path 변수의 수는 $N$!개로 증가할 수 있다. 그렇기 때문에 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;column generation을 사용&lt;/b&gt;한다. 
&lt;br /&gt;&lt;br /&gt;

&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Branch-and-Price&lt;/b&gt;는 흔히 사용되는 branching 기법이다. column generation을 할 때 reduced cost를 확인하여 제한된 모델에 추가될 새로운 변수를 찾는데 이러한 과정을 pricing이라 한다. 더 이상 추가할 column이 없을 때까지 반복하며 변수가 fractional인 경우에는 branching을 해준다. 일반적으로 set partitioning 제약식(11)은 set covering 제약으로 바뀐다. 
&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
The pricing scheme
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
$\pi_i$와 $\pi_0$을 각각 제약식 (11)과 (12)에 대한 dual 이라고 한다면 reduced cost는 다음과 같다.
$$
\begin{aligned}
rc(p) = c(p) - \sum^N_{i=1} a^p_i \pi_i - \pi_0 = \sum_{(i,j) \in p} (d(i,j)-\pi_j) - \pi_0
\end{aligned}
$$
&lt;br /&gt;
따라서 subproblem은 다음과 같은 cost를 가지고 용량을 넘지 않는 the shortest elementary path를 찾는 문제가 된다. 
$$
\begin{aligned}
&amp;amp;rc(i,j) = d(i,j)-\pi_j \quad \forall j \in \{1,\ldots,N\}, \\
&amp;amp;rc(i,N+1) = -\pi_0.
\end{aligned}
$$
&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Various possible subproblems
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
path $p = (i_0 = 0, i_1, \ldots, (N+1))$라 하자. resources는 $L$로 일반화 될 수 있고 $l$에 의해 인덱싱된다. $D^l_i$는 노드 $i$에서 resource $l$의 누적된 양을 나타낸다. 거리 함수 $d^l(i,j)$는 $i$와 $j$사이의 resource $l$의 누적을 정의한다. $[a^l_i,b^l_i]$는 resource와 노드 각각의 쌍으로 정의된다. 여기서는 두 개의 연속적인 노드 $i$와 $j$ 사이의 누적된 resource의 증가는 triangle inequality를 만족해야한다는 것을 이용한다.
$$
\begin{aligned}
d^l(i,k) \leqslant d^l(i,j) + d^l(j,k) \quad \forall l = 1\ldots L.
\end{aligned}
$$
&lt;br /&gt;
&lt;b&gt;Theorem 1.&lt;/b&gt; triangle inequality에 대한 resource 누적과 노드 사이의 cost 누적이 strictly positive일 때, non-elementary path를 가지는 마스터 문제의 optimal integer solution은 elementary path만을 포함한다. 
&lt;br /&gt;&lt;br /&gt;
일반적으로 최단경로 서브문제는 cycle이 허용되는 pseudo-polynomial labeling algorithm으로 풀린다. 그러나 elementary path만 사용된다면 relaxed 마스터 문제는 더 제한되고 더 좋은 bound가 제공될 것이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Labeling algorithm
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
노드 $i$에서 partial path $p$는 label $E_p = (rc_p, D^0_p, \ldots , D^L_p)$와 관련되어 있다. 레이블링 알고리즘에서 사용되는 기본적인 rule은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;dominance rule&lt;/b&gt;이고 다음을 만족하면 partial path $p_1$은 다른 partial path $p_2$를 dominate한다. 
$$
\begin{align}
&amp;amp;rc_1 \leqslant rc_2, \\
&amp;amp;D^l_1 \leqslant D^l_2 \quad \forall l \in \{0,\ldots L\}
\end{align}
$$

dominance rule은 elementary shortes path에 직접적으로 사용될 수 없다. 따라서 이 논문의 중점은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;실질적이고 효율적인 알고리즘의 수정을 제안하는 것&lt;/b&gt;이다. 
&lt;br /&gt;&lt;br /&gt;
이 논문에서는 Ryan-Foster rules에 기초한 branching 기법을 사용한다. 같은 node $i$와 $j$를 공유하는 두 개의 fractional routes를 찾는다. (한 경로는 arc $(i,j)$를 사용하고 다른 경로는 사용하지 않는다.) 각 branch에서 최단 경로 서브문제는 문제의 구조를 깨지 않고 쉽게 수정될 수 있다. 
&lt;br /&gt;&lt;br /&gt;
좋지 않은 lower bound를 가지는 노드를 prune하기 위해 bound의 quality가 중요한데 이 논문에서는 relaxation의 quality를 향상하기 위한 두 가지 방법을 제시한다. 첫 번째는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;relaxation에 cutting plane을 추가하는 것&lt;/b&gt;이고 두 번째는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;elementary shortest path subproblem에 기초한 것&lt;/b&gt;이다. SPRCTW를 사용할 경우 마스터 문제를 MP로 표시하고 ESPRCTW를 사용할 경우 EMP로 표시한다. MP에서 통합 제약을 제거하면 RMP로 표시하고 EMP에서 제거하면 REMP로 표시한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Simple example
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
depot에서 매우 먼 두 개의 노드 $i$와 $j$를 가지는 문제에 대해 다음과 같이 가정한다.
$$
\begin{aligned}
&amp;amp;d(0,i) = d(0,j) = 100,\\
&amp;amp;d(i,j) == 1.
\end{aligned}
$$
용량과 time window는 크다고 가정한다. EMP의 optimal relaxed solution은 $LB_{elem}$ = 201 이 되도록 unique route 0-$i$-$j$-$(N+1)$로 만들어 진다. cycles가 허용되면 0-$(i-j)^n$-($N$+1)의 route 형식으로 $i$-$j$가 $n$번 반복된다. 

&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/4_fig1.png&quot; width=&quot;350&quot; height=&quot;360&quot; /&gt;
&lt;/p&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Use of cuts
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
relaxed problem으로 부터 얻은 솔루션을 향상시키는 가장 흔한 방법은 $k$-path cuts과 같은 cutting plane을 추가하는 것이다. 
$S$를 노드 집합, $\delta(S)$를 $S$에서의 outgoing arcs의 집합 ($\delta(S)$ = {($i$,$j$ $\in$ $A$/ $i$ $\in$ $S$, $j$ $\notin$ $S$}), $\mu^p_S$를 path $p$가 $\delta(S)$에서 가지는 arcs의 수라고 하자. 
어떤 $k$ $\leqslant$ $\kappa(S)$에 대해 그 집합에서 최소 한개의 노드를 포함하는 경로에 해당하는 변수 $\lambda$에 $k$-path cut으로 알려진 새로운 제약을 다음과 같이 추가할 수 있다. 
$$
\begin{aligned}
\sum_{p \in \Omega} \mu^p_S \lambda^p \geqslant k.
\end{aligned}
$$
cut을 추가하는 것은 lower bound를 향상 시킬 수 있다. 그러나 MP에 subtour cut을 추가하여 얻은 bound는 EMP에서 얻은 bound와 같지 않다. 예를 들어 세 개의 노드 $i$, $j$, $k$를 가지고 있다고 가정하면 경로의 집합은 각각 $
\frac{1}{2}$의 값을 가질 수 있다. 
&lt;br /&gt;&lt;br /&gt;
0-$j$-$k$-($N$+1),
&lt;br /&gt;
0-$i$-$j$-$k$-$i$-($N$+1).
&lt;br /&gt;&lt;br /&gt;
이 솔루션이 어떤 subtour cut을 위반하지 않더라도 cycle을 포함하여 EMP의 솔루션이 될 수 없을 것이다. ESP가 풀기 더 어렵지만 cutting plane을 사용할 때 relaxation에 추가되는 violated cut을 분리하기 위해 다른 복잡한 알고리즘을 사용해야만 한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Use of elementary paths
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
MP와 EMP의 제약조건이 동일하고 column 집합이 다른 하나에 포함되어 있으면 MP는 EMP의 relaxation이고 RMP는 REMP의 relaxation이다. 따라서 서브문제에 ESPRCTW를 사용한다. 알고리즘의 worst practical efficiency와 better quality of bounds 사이에서 적절한 타협점을 갖도록 한다. 
&lt;br /&gt;&lt;br /&gt;
elementary path 문제에 대한 labeling algorithm의 수정에 대해 제안하는데 두 개의 주요한 차이점이 적용된다.

&lt;ol&gt;
&lt;li&gt;partial route는 부분 경로에서 이미 존재하는 노드로 갈 수 없다. &lt;/li&gt;
&lt;li&gt;label은 dominance rule을 사용하여 직접적으로 파악할 수 없다.&lt;/li&gt;
&lt;/ol&gt;

첫 번째 항목은 $i$에서 끝나는 부분 경로는 아직 방문하지 않은 $j$로만 갈 수 있다는 의미이다. 두 번째 항목이 문제의 주된 어려움이므로 지배 규칙을 개선시키는 것을 목표로 한다. 새로운 지배 규칙은 최적해의 일부가 아니라 가능한 많은 부분 경로를 가능한 빨리 파악할 수 있게 해야한다.
&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
A preliminary modified dominance rule
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
수정된 지배 규칙은 부분 경로 $p_1$이 다른 부분 경로 $p_2$를 지배하는 충분 조건이 (13)과 (14) 조건을 만족하고 노드 집합 $V(p_2)$에 $V(p_1)$을 포함할 때 사용된다. 
$$
\begin{align}
V(p_1) \subseteq V(p_2).
\end{align}
$$
기본적인 새로운 지배 규칙은 많은 레이블을 만들어낼 것이다. 실제로 노드의 집합이 다른 것에 포함되지 않는((15)를 만족하지 않는) 두 개의 부분 경로는 지배 규칙에 해당되지 않는다. 따라서 이 규칙에 대한 complete 수정과 heuristic 수정에 대한 개선을 소개한다. 
&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Exact improvement of the dominance rule
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
$p_1$의 일부 노드를 거치면서 얻을 수 있는 reduced cost의 예상되는 개선을 추정함으로써 지배 규칙을 향상시킬 수 있다. 
$p_1$과 $p_2$를 같은 노드 $m$에서 끝나는 두 개의 부분 경로라고 하자. $V(p)$는 부분 경로 $p$에 의해 방문된 노드의 집합이다. $V(p_1)$ \ $V(p_2)$ = {n}일 때 근사치를 고려해보자.
&lt;br /&gt;&lt;br /&gt;
1. Bound on improvement with $\pi_n$ : $p^*_2$가 부분 경로 $p_2$의 확장이기 때문에 $n$을 제외하고 $p^*_1$을 같은 방법으로 만들 수 있다. $p^*_2$에서 이전 노드 $i$와 다음 노드 $j$를 사용하여 다음과 같이 나타낼 수 있다. 
$$
\begin{aligned}
rc^*_2 - rc^*_1 = c(i,n) + c(n,j) - c(i,j) - \pi_n + rc_2 -rc_1.
\end{aligned}
$$
따라서 다음과 같은 경우에만 $p^*_2$가 $p^*_1$보다 더 좋다. 
$$
\begin{aligned}
 c(i,n) + c(n,j) - c(i,j) - \pi_n + rc_2 -rc_1 &amp;lt; 0.
\end{aligned}
$$
비용 부분(triangle inequality로 인해 항상 양수이다)을 과소평가함으로써 $p_2$를 제거하기 위한 충분 조건은 다음과 같다.
$$
\begin{align}
- \pi_n \geqslant rc_1 -rc_2.
\end{align}
$$
2. Bounds on improvement with $\pi_n$ − $minAddedArcCost_n$: 비용 부분의 더 나은 근사를 사용하고 다음과 같은 식을 사용하여 과소평가 한다. 
$$
\begin{align}
minAddedArcCost_n = min_{i\in prec(n),j\in succ(n)}(c(i, n) + c(n, j) − c(i, j)),
\end{align}
$$
$prec(n)$은 노드 $n$의 가능한 predecessors의 집합, $succ(n)$은 가능한 successors의 집합이다. 이는 각 노드 $n$에 대한 알고리즘 초기화 단계에서 계산될 수 있다. 따라서 충분 조건은 다음과 같다.
$$
\begin{align}
minAddedArcCost_n - \pi_n \geqslant rc_1 - rc_2.
\end{align}
$$
(16)과 (17) 두 개의 조건은 더 많은 레이블을 파악하는데 사용될 수 있다. 이러한 조건들은 $Card(V(p_1)$\ $V(p_2))$ &amp;gt; 1인 경우에 일반화 될 수 있다. 그러나 좋은 bound를 찾는 것이 어렵기 때문에 알고리즘을 $Card(V(p_1)$\ $V(p_2))$ $\leqslant$ 2인 경우로 제한했다.
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
Computational Results
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
데이터는 Solomon을 사용한다. Table 1에서는 R1과 RC1에서 얻은 bound를 [11]과 비교한다. 
&lt;ul&gt;
&lt;li&gt;$i$-$j$-$i$ 형태의 cycle만 금지하는 서브문제에 해당하는 $LB$와 [11]의 $LB(1)$ 비교 &lt;/li&gt;
&lt;li&gt;Branch-and-Price root node에 subtour cut과 2-path cut을 추가한 $LB(2)$와 [11]의 $LB(1)$ 비교 &lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/4_table1.png&quot; width=&quot;600&quot; height=&quot;160&quot; /&gt;
&lt;/p&gt;
평균적으로 이 논문에서 제시한 lower bonud와 최적해의 갭은 $LB(1)$과 최적해의 갭보다 17% 더 작았다. $LB(2)$를 사용한 것은 갭이 47% 더 작았다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/4_table2.png&quot; width=&quot;600&quot; height=&quot;460&quot; /&gt;
&lt;/p&gt;

Table 2는 series 2의 instance에 대해 얻은 lower bound 향상에 대한 디테일을 제공한다. RC2 instance 대부분에 대한 향상된 bound는 integral solution에 해당하고 branching이 필요하지 않다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/4_table3.png&quot; width=&quot;600&quot; height=&quot;460&quot; /&gt;
&lt;/p&gt;
Table 3은 17개의 Solomon instance에 대한 결과이다. OPT는 optimal solution 값을 나타내고 V는 사용된 차량의 수를 나타낸다. Gap은 Branch-and-Price root node와 optimal solution 사이의 차이이고 N은 Branch-and-Price 노드의 수, SP는 풀린 서브 문제의 수, $T_{opt}$는 최적해를 찾는 시간, $T_{proof}$는 optimality를 증명하는 시간을 뜻한다. (*)와 (**)는 각각 [12,13]에서 제시된 최적해보다 더 좋은 값이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/4_table4.png&quot; width=&quot;600&quot; height=&quot;460&quot; /&gt;
&lt;/p&gt;
Table 4는 솔로몬의 전체 instance에 대한 결과이다. 시간 제한은 1시간으로 두고 이전과 동일한 계산 조건을 사용한다. gap은 발견된 솔루션에서 가장 좋은 lower bound의 차이를 뜻하고 OPT는 최적에 도달한 경우의 수와 괄호안에 최적화가 입증된 경우의 수를 나타낸다. 시간 제한이 있기 때문에 최적해가 증명되지 않아도 발견될 수 있다. 
&lt;br /&gt;&lt;br /&gt;
논문의 결론은 다음과 같이 정리할 수 있다. 
&lt;ul&gt;
&lt;li&gt;일반적인 elementary shortest path 알고리즘에 대한 개선을 제안한다.&lt;/li&gt;
&lt;li&gt;elementary shortest path가 수정된 알고리즘이 사용될 때 실질적으로 유용함을 보여준다. &lt;/li&gt;
&lt;li&gt;새로운 최적해를 찾기 위해 cutting planes를 사용하는 것은 lower bound를 향상시키는 또다른 방법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Cite
&lt;/div&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; font-family: Times New Roman; &quot;&gt;
Chabrier, A. (2006). Vehicle routing problem with elementary shortest path based column generation. &lt;i&gt;Computers &amp;amp; Operations Research, 33&lt;/i&gt;(10), 2972-2990.

&lt;/span&gt;
&lt;span style=&quot;font-weight:400; font-size:1.0em;&quot;&gt;
&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0305054805000857?casa_token=ZPCq16G80LAAAAAA:jTn_BT6tAUSeosl45Kg3TMddtEtnnsgG35TAvG_JnBlEVpFw51RJynwfPkR7BoTdFZtD_rvj7Q&quot;&gt; 논문 링크 &lt;/a&gt;
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 09 May 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/%EB%85%BC%EB%AC%B8%20%EB%A6%AC%EB%B7%B04/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/%EB%85%BC%EB%AC%B8%20%EB%A6%AC%EB%B7%B04/</guid>
        
        
        <category>논문리뷰</category>
        
      </item>
    
      <item>
        <title>논문리뷰 - Solving vehicle routing problem by using improved genetic algorithm for optimal solution</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Abstract &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Context&lt;/b&gt; : The Vehicle Routing Problem (VRP) has numerous applications in real life. It clarifies in a wide area of transportation and distribution such as transportation of individuals and items, conveyance service and garbage collection. Thus, an appropriate selecting of vehicle routing has an extensive influence role to improve the economic interests and appropriateness of logistics planning.&lt;br /&gt;&lt;br /&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Problem&lt;/b&gt; : In this study the problem is as follows: Universiti Tenaga Nasional (UNITEN) has eight buses which are used for transporting students within the campus. Each bus starts from a main location at different times every day. The bus picks up students from eight locations inside the campus in two different routes and returns back to the main location at specific times every day, starting from early morning until the end of official working hours, on the following conditions: Every location will be visited once in each route and the capacity of each bus is enough for all students included in each route. &lt;br /&gt;&lt;br /&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Objectives&lt;/b&gt; : Our paper attempt to find an optimal route result for VRP of UNITEN by using genetic algorithm. To achieve an optimal solution for VRP of UNITEN with the accompanying targets: To reduce the time consuming and distance for all paths. which leads to the speedy transportation of students to their locations, to reduce the transportation costs such as fuel utilization and additionally the vehicle upkeep costs, to implement the Capacitated Vehicle Routing Problem (CVRP) model for optimizing UNITEN’s shuttle bus services. To implement the algorithm which can be used and applied for any problems in the like of UNITEN VRP. &lt;br /&gt;&lt;br /&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Approach&lt;/b&gt; : The Approach has been presented based on two phases: firstly, find the shortest route for VRP to help UNITEN University reduce student’s transportation costs by genetic algorithm is used to solve this problem as it is capable of solving many complex problems; secondly, identify The CVRP model is implemented for optimizing UNITEN shuttle bus services.&lt;br /&gt;&lt;br /&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Finding&lt;/b&gt; : The findings outcome from this study have shown that: (1) A comprehensive listed of active GACVRP; (2) Identified and established an evaluation criterion for GACVRP of UNITEN; (3) Highlight the methods, based on hybrid crossover operation, for selecting the best way (4) genetic algorithm finds a shorter distance for route A and route B. The proportion of reduction the distance for each route is relatively short, but the savings in the distance becomes greater when calculating the total distances traveled by all buses daily or monthly. This applies also to the time factor that has been reduced slightly based on the rate of reduction in the distances of the routes.&lt;br /&gt;&lt;br /&gt;
&lt;em&gt;Keywords : Genetic algorithm; Vehicle routing problem; Capacitated vehicle routing problem; Optimal solution &lt;/em&gt; 
&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Summary
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

이 논문은 유전 알고리즘을 이용해 UNITEN의 CVRP에 대한 최적의 경로 결과를 찾는다. 각 경로의 거리 감소 비율은 상대적으로 작지만, 모든 버스가 매일 또는 매월 운행하는 총 거리에 대한 절약량은 더 커진다.

&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;본문 내용
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify;  &quot;&gt;

VRP(Vehicle Routing Problem)는 실생활에서 다양한 응용분야가 있으며 그중 운송(물류) 분야에 적용이 많이 된다. 이 논문에서는 UNITEN(Universiti Tenaga Nasional)의 셔틀버스 운행에 관한 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;CVRP&lt;/b&gt; (Capacitated Vehicle Routing Problem) 문제를 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;유전알고리즘&lt;/b&gt;을 사용하여 푼다. 8개의 버스가 운행되고 main location에서 매일 다른 시간에 출발한다. 버스는 8개의 다른 location에서 2개의 다른 경로로 학생들을 픽업하고 main location으로 돌아온다. 모든 location은 각 경로에서 한번 방문되고 버스는 모든 학생을 태우기에 충분한 capacity를 가진다고 가정한다. 

&lt;br /&gt;&lt;br /&gt;
이 논문에서는 UNITEN CVRP의 optimal solution을 얻기 위해 다음을 목표로 한다.
&lt;ol&gt;
&lt;li&gt;모든 path에 대한 시간 소모와 거리를 줄이는 것 (빠른 수송을 가능하게 함)&lt;/li&gt;
&lt;li&gt;연료 사용과 추가적인 차량 유지 비용 등의 운송 비용을 줄이는 것&lt;/li&gt;
&lt;li&gt;UNITEN의 셔틀 버스 서비스를 최적화하는 CVRP 모델을 구현하는 것&lt;/li&gt;
&lt;li&gt;UNITEN CVRP와 같은 문제에 적용될 수 있는 알고리즘을 구현하는 것&lt;/li&gt;
&lt;/ol&gt;

유전 알고리즘은 large space에 대한 복잡한 문제를 해결하는데 효과적이라 VRP의 다양한 유형을 풀 때 사용되지만 CVRP를 푸는데는 거의 사용되지 않았다. 따라서 이 논문에서는 CVRP를 유전 알고리즘으로 풀고자한다. 
&lt;br /&gt;&lt;br /&gt;

그래프 Gr은 다음과 같이 표현된다. S는 station 집합, D는 station 사이의 거리를 의미한다. 
$$Gr = (S,D); S = {s_0,s_1,...,s_n}, D = {(s_x,s_y):s_x,s_y \in S, x &amp;lt; y} $$
$z$개의 차량에 대해 Decision factor function이 다음과 같이 rout 옵션을 결정한다.
$$
D f(x, y, z)\left\{\begin{array}{ll}1, &amp;amp; \text { true } \longleftarrow \operatorname{arc}(x, y) \\ &amp;amp; 0, \quad \text { otherwise }\end{array}\right.
$$
$z$는 경로의 거리를 줄이기 위해 1로 가정하고 CVRP를 formulation 한다.
$$
\text { Minimize }=\left(\sum_{x=0, x \neq y}^{n} D_{x, y} D f_{x, y}\right) \\
\text {Therefore } x=0, y=1 \text { are subject to:} \\
Df_{x,y} = 1, \quad \forall x \in S \\
Df_{x,y} = 1, \quad \forall y \in S \\
f(x) = 100 / \sum_{x=0,y=1}^n D_{x,y}
$$
모든 path에 대한 최소 비용은 거리에 의존하기 때문에 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;염색체(chromosome)의 fitness value를 높이기 위해 거리를 줄여야&lt;/b&gt; 한다. 위의 $f(x)$는 fitness를 의미한다. (CVRP 모델이 이상하다..)
&lt;br /&gt;&lt;br /&gt;
이러한 CVRP모델을 푸는 유전알고리즘 과정은 다음과 같다.  
&lt;br /&gt;&lt;br /&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/ga.png&quot; width=&quot;600&quot; height=&quot;460&quot; /&gt;
&lt;/p&gt;

이를 flow chart로 나타내면 다음과 같다. 

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/ga_flowchart.png&quot; width=&quot;400&quot; height=&quot;660&quot; /&gt;
&lt;/p&gt;

이 논문에서 사용된 유전 알고리즘 연산으로 모집단, 적합도, 선택, 교차, 변이가 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
모집단 (Population)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
모집단은 랜덤하게 생성된다. 각각의 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;염색체(chromosome)&lt;/b&gt;는 하나의 유효한 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;경로(route)&lt;/b&gt;를 나타내고 각 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;location&lt;/b&gt;은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;유전자(gene)&lt;/b&gt;에 해당한다. 초기 모집단인 첫번째 염색체는 다음과 같이 표현된다.
$$
1\quad 2\quad 3\quad 4\quad 5\quad 6\quad 7\quad 8\quad 9
$$ 
초기 염색체가 생성되면 적합도(fitness)가 계산되고 가장 좋은 염색체로 설정된다.

&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
적합치 (Fitness values)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
UNITEN CVRP에서 모든 path의 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;최소 비용은 거리에 의존&lt;/b&gt;한다. 염색체의 적합도는 모든 path에 대한 총 거리를 구하여 계산할 수 있다. path 거리는 D1 = station 1에서 stop 2 , D2 = station 2에서 stop 5까지의 거리 등 축약해서 나타낸다. 염색체 적합도를 높이기 위해 거리를 줄여야하고 적합도는 (100/총 거리의 합)으로 나타낸다. 

&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
선택 (Selection)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
Strong selective factor는 혼합(hybrid) 교차를 위한 최적의 염색체만을 선택하여 가장 이상적인 솔루션을 유도할 수 있다. 이는 유전 알고리즘을 빨리 끝낼 수 있게 한다. 반면 Weak selective factor는 혼합 교차에서 적합도가 낮은 솔루션까지 확인해야함으로 더 많은 시간이 걸린다. 기존의 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;룰렛 휠(roulette wheel)&lt;/b&gt;은 가장 높은 적합도를 가지는 염색체를 선택하여 새로운 염색체를 만들고 이를 복제하여 새로운 세대(generation)를 형성하는 염색체 선택 방식이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
교차 (Crossover)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
랜덤 벡터를 생성하여 유전자를 선택하는 혼합교차가 이 알고리즘에서 사용되었다. 1이면 primary parent에서 0이면 second parent의 유전자를 선택하고 이를 결합하여 자손을 만든다. 예를 들어 부모 C1과 C2가 다음과 같이 주어지고 이진 벡터가 [10101001]이라면 자손1이 다음과 같이 생성된다.
&lt;br /&gt;&lt;br /&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/crossover.png&quot; width=&quot;350&quot; height=&quot;80&quot; /&gt;
&lt;/p&gt;

&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
변이 (Mutation)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
유전 알고리즘 연산을 계속 진행하면 local optimum에 도달하게 되는데 새로운 염색체에 확률적으로 돌연변이를 발생시켜 local optimum에서 빠져나올 수 있도록 한다. 돌연변이 체계는 모든 루프에서 3가지 상황을 반복한다. 첫 번째 염색체의 대체 염색체를 생성하며 테스트하고 두 개의 결과 유전자 사이에 immediate route가 없으면 새로운 염색체는 무효가 된다. 만약 새로운 염색체가 좋다면 적합도 함수 값이 계산된다. 만약 적합도 함수 값이 기존보다 우수하면 새로운 염색체가 best가 되고 루프가 종료된다. 
&lt;br /&gt;&lt;br /&gt;


&lt;span style=&quot;font-weight:700; font-size:1.2em;  margin-right: 1em;&quot;&gt;
결과 (Results)
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
이 연구는 UNITEN에서 학생들의 총 교통비를 줄이는 것을 목표로 하며 비용은 주로 경로의 거리에 관한 것이다. 향상된 유전 알고리즘은 테스트와 검증을 통해 station 양에 가장 적합한 경로를 찾는 것이 입증되었다. 버스는 학생들을 수송하기 위해 매일 A와 B 두 개의 경로로 운행된다. 

&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;display: inline-block; margin-left: 0.55em;  &quot;&gt;
&lt;img src=&quot;/images/post_img/table1.png&quot; width=&quot;300&quot; height=&quot;120&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;display: inline-block; margin-left: 0.55em; &quot;&gt;
&lt;img src=&quot;/images/post_img/table2.png&quot; width=&quot;300&quot; height=&quot;115&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;display: inline-block; margin-left: 0.75em;  &quot;&gt;
&lt;img src=&quot;/images/post_img/table3.png&quot; width=&quot;300&quot; height=&quot;120&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;display: inline-block; margin-left: 0.75em; &quot;&gt;
&lt;img src=&quot;/images/post_img/table4.png&quot; width=&quot;300&quot; height=&quot;115&quot; /&gt;
&lt;/div&gt;

Table 1은 기존 경로의 거리를 나타내고 Table 2는 새로운 경로의 거리를 나타낸다. Table 3은 이 둘의 차이를 나타내고 Table 4는 거리 감소에 대한 비용 절약정도를 나타낸다. 
&lt;br /&gt;&lt;br /&gt;
&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;각 경로의 거리 감소 정도는 작지만 두 경로에 대한 장기적인 감소는 크다.&lt;/b&gt; 알고리즘의 성능과 신뢰성을 검증하기 위해 UKM의 동일한 문제를 풀기 위해 적용되었고 더 짧은 경로를 찾는데 성공하였다. UKM 각 경로의 거리 감소는 꽤 크다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/3_fig2.png&quot; width=&quot;600&quot; height=&quot;360&quot; /&gt;
&lt;/p&gt;

&lt;br /&gt;&lt;br /&gt;
논문의 결론은 다음과 같이 정리할 수 있다. 
&lt;ul&gt;

&lt;li&gt;UNITEN의 셔틀 버스 서비스를 최적화하기 위해 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;CVRP 모델&lt;/b&gt;을 구현하고 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;유전 알고리즘&lt;/b&gt;을 활용하여 이를 해결하였다.&lt;/li&gt;
&lt;li&gt;그러나 알고리즘에서 단일 변수인 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;거리&lt;/b&gt;만 고려하고 버스 정류장이 적고 한정되어 있어 솔루션을 찾기가 상당히 쉽기 때문에 복잡한 문제를 효율적으로 처리하는 것으로 알려진 유전 알고리즘의 강점을 드러내지 않았다는 한계점이 있다.&lt;/li&gt;
&lt;li&gt;추후에는 Selangor와 UNITEN의 다른 locations간의 최단 거리를 찾는 알고리즘으로 확장할 것이다.&lt;/li&gt;
&lt;/ul&gt;

보통 유전알고리즘으로 CVRP 문제를 안푸는 이유는 잘 풀리지 않기 때문이라고 한다. 이 논문은 너무 작은 문제에 대해서 풀기도 했고 그냥 수리모형으로 formulation했으면 더 큰 문제도 금방 풀었을텐데 의미가 거의 없는 논문이라고 할 수 있다. 논문을 고를 때 좋은 논문을 고를 수 있도록 더 많은 논문을 읽어봐야겠다.


&lt;hr /&gt;


&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Cite
&lt;/div&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; font-family: Times New Roman; &quot;&gt;
Mohammed, M. A., Ghani, M. K. A., Hamed, R. I., Mostafa, S. A., Ahmad, M. S., &amp;amp; Ibrahim, D. A. (2017). Solving vehicle routing problem by using improved genetic algorithm for optimal solution. &lt;i&gt;Journal of Computational Science, 21,&lt;/i&gt; 255-262.
&lt;/span&gt;
&lt;span style=&quot;font-weight:400; font-size:1.0em;&quot;&gt;
&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S1877750317303848?casa_token=9Y5bAxWb2eIAAAAA:4nDqYopNV9xWFF64pz6X9yVt7MMBNFGP1FC490oSKSd1dSVbpQRF60KEf1uHrwj2HKF8J3HqAg&quot;&gt; 논문 링크 &lt;/a&gt;
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 25 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/%EB%85%BC%EB%AC%B8%20%EB%A6%AC%EB%B7%B03/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/%EB%85%BC%EB%AC%B8%20%EB%A6%AC%EB%B7%B03/</guid>
        
        
        <category>논문리뷰</category>
        
      </item>
    
      <item>
        <title>IP - Lagrangian Duality</title>
        <description>&lt;hr /&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Lagrangian Relaxation
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
다음과 같은 IP(Integer program)를 생각해보자. 

$$
\begin{aligned}
    \text{(IP)} \quad &amp;amp;z=\max cx \\
    &amp;amp;Ax \le b \\
    &amp;amp;Dx \le d  \\
    &amp;amp;x \in Z^n_+
\end{aligned}
$$

어떤 제약조건만 있는 IP는 쉽게 풀린다는 관점에서 $Ax \le b$ 식을 &quot;nice&quot;하다고 가정해보자. 그러면 복잡한(complicating) 제약식 $Dx \le d$만 없다면 원래 IP 문제를 푸는 것 보다 relaxation이 더 쉬워진다. 많은 문제들이 이처럼 나이스한 제약과 복잡한 제약을 동시에 갖고 있는데, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;복잡한 제약을 없앨 수 있다면 쉽게 문제를 풀 수도 있을 것&lt;/b&gt;이다. 예를 들어 TSP (traveling salesman problem)의 connectivity 제약식, UFL(uncapacitated facility location)의 client demand 제약식 등 복잡한 제약을 없앨 수 있다면 말이다. 그러나 그냥 없애버리면 중요한 제약식이 전부 무시되기 때문에 relaxation의 bound가 매우 좋지 않으므로 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Lagrangian relaxation&lt;/b&gt;을 사용하고자 한다. 

&lt;br /&gt;&lt;br /&gt;
IP 문제를 좀더 간단하게 일반적인 폼 (general form)으로 바꿔보자. 

$$
\begin{aligned}
    &amp;amp;z=\max cx \\
    &amp;amp;Dx \le d  \\
    &amp;amp;x \in X
\end{aligned}
$$

여기서 $Dx \le d $는 $m$개의 복잡한 제약식이다. 

&lt;br /&gt;&lt;br /&gt;

어떤 값 $u = (u_1, ... , u_m) \ge 0$ 에 대해 다음과 같이 IP의 relaxation을 정의하자. 

$$
\begin{aligned}
    \text{(IP(u))} \quad &amp;amp;z(u)=\max cx + u(d-Dx)\\
    &amp;amp;x \in X
\end{aligned}
$$

IP($u$)는 $\{x : Dx \le d, x \in X\} \subseteq X $ 이므로 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;feasibel region&lt;/b&gt;은 같거나 크고, $u \ge 0$ 이고 모든 $x \in X$에 대해 $(d-Dx) \ge 0$이므로 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;목적값(objective value)&lt;/b&gt; 또한 원래 IP 문제보다 같거나 크다. 

&lt;br /&gt;&lt;br /&gt;

IP($u$)에서 복잡한 제약식이 목적함수의 penalty term인 $u(d-Dx)$으로 추가됨으로써 다루어지는 것을 볼 수 있다. 이 때 $u$ 를 $Dx \le d$ 제약에 대한 &lt;i&gt;&lt;b style=&quot;color:#d7385e; &quot;&gt;Lagrange multiplier&lt;/b&gt;&lt;/i&gt; (&lt;i&gt;price&lt;/i&gt;, &lt;i&gt;dual variable&lt;/i&gt;) 라고 한다. 
&lt;br /&gt;&lt;br /&gt;

따라서 IP($u$)를 파라미터 $u$를 가진 IP의 &lt;i&gt;Lagrangian relaxation (subproblem)&lt;/i&gt;이라 부른다. IP($u$)는 IP의 relaxation이기 때문에 $z(u) \ge z$이고 IP의 최적값(opmial value)의 upper bound를 얻을 수 있다. 가장 좋은 upper bound를 찾기 위해 &lt;i&gt;&lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;Lagrangian Dual Problem&lt;/b&gt;&lt;/i&gt;을 푼다. 
&lt;br /&gt;&lt;br /&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/max_relaxation_bound.png&quot; width=&quot;350&quot; height=&quot;170&quot; /&gt;
&lt;/p&gt;
Lagrangian Dual Problem은 다음과 같이 정의한다. 

$$
\begin{aligned}
    \text{(LD)} \quad &amp;amp;w_{LD}=\min \{z(u) : u \ge 0 \} 
\end{aligned}
$$

Lagrangian relaxation을 풀어 IP의 최적 솔루션을 찾을 수도 있다.
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;border: 0px solid red; text-align: left; margin: 0 auto; width:45% &quot;&gt;
 IF $u \ge 0$, &lt;br /&gt;
1. $x(u)$는 IP($u$)의 &lt;i&gt;optimal solution&lt;/i&gt;이고 &lt;br /&gt;
2. $D(x) \le d$ 이고 &lt;br /&gt;  
3. $u_i &amp;gt; 0$일 경우, $(Dx(u))_i = d_i$&lt;br /&gt;
THEN $x(u)$는 IP의 optimal이다.
&lt;/div&gt;
&lt;br /&gt;
1에 의해 $w_{LD} \le z(u)$이고, 3에 의해 $cx(u)+u(d-Dx(u)) = cx(u)$이다. 2에 의해 $x(u)$는 IP에서 feasible이고 따라서 $cx(u) \le z$ 이다. 그러므로 $w_{LD} \le z(u) = cx(u) \le z$이고 equality 제약으로 인해 $w_{LD} \ge z$이므로 $x(u)$는 IP에서 optimal이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Application - UFL
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
UFL 문제에 이를 적용해 보자. 먼저, strong formulation으로 시작한다. 
$$
\begin{aligned}
    \text{(IP)} \quad z=\max &amp;amp;\sum_{i \in M} \sum_{j \in N} c_{ij}x_{ij} - \sum_{j \in N} f_j y_j \\
    &amp;amp;\sum_{j \in N} x_{ij} = 1 \quad \forall i \in M  \\
    &amp;amp;x_{ij}-y_j \le 0 \quad \forall i \in M, j \in N \\ 
    &amp;amp;x \in R^{|M|\times|N|}, y \in B^{|N|}
\end{aligned}
$$

demand 제약식을 dualizing한다.
$$
\begin{aligned}
    \text{(IP($u$))} \quad z=\max &amp;amp;\sum_{i \in M} \sum_{j \in N} (c_{ij}-u_i)x_{ij} - \sum_{j \in N} f_j y_j + \sum_{i \in M}u_i \\
    &amp;amp;x_{ij}-y_j \le 0 \quad \forall i \in M, j \in N \\ 
    &amp;amp;x \in R^{|M|\times|N|}, y \in B^{|N|}
\end{aligned}
$$
이는 각 location에 대한 subproblem으로 갈라진다. 
$$
\begin{aligned}
    \text{(IP}_j(u)) \quad z_j(u)=\max &amp;amp;\sum_{i \in M} (c_{ij}-u_i)x_{ij} - f_j y_j \\
    &amp;amp;x_{ij}-y_j \le 0 \quad \forall i \in M \\ 
    &amp;amp;x_{ij} \ge 0 \quad \forall i \in M, y_i \in B^1
\end{aligned}
$$

따라서 $IP_j(u)$이면 $z(u) = \sum_{j \in N} z_j(u) + \sum_{i \in M} u_i$이다. 
만약 $y_j = 0$이면 모든 $i$에 대해 $x_{ij} = 0$이고 목적값은 0이 된다. 만약 $y_j=1$이면 profitable한 모든 고객은 서비스를 받으므로 $c_{ij}-u_i &amp;gt;0$이다. 따라서 $z_j(u) = \max \{0, \sum_{i \in M} \max [c_{ij}-u_i, 0]-f_j\}$이다.
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
UFL Example
&lt;/span&gt;

&lt;br /&gt;&lt;br /&gt;
이와 관련된 간단한 예시를 들어보자. $m = 6$인 clients와 $n=5$인 potential locations가 있고 fixed location cost $f = (2,4,5,3,3)$이고 client-location profit matrix($c_{ij}$)는 왼쪽과 같다고 하자. $u=(5,6,3,2,5,4)$라 하면 ($c_{ij}-u_i$)를 오른쪽과 같이 나타낼 수 있다. 
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;display: inline-block; margin-left: 0.5em; margin-right: 0.5em; &quot;&gt;
&lt;img src=&quot;/images/post_img/ex1.png&quot; width=&quot;250&quot; height=&quot;150&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;display: inline-block; margin-right: 0.5em; &quot;&gt;
&lt;img src=&quot;/images/post_img/ex2.png&quot; width=&quot;300&quot; height=&quot;150&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
모든 $j = 2$에 대해 $y_2=0$이면 0의 값을 얻고 $y_2=1$이면 $x_{22}=1$, $x_{52}=1$로 설정하여 $y_2=1$인 net profit이 7-4 = 3이 된다. 그러므로 $z_2(u)=3$을 주는 $y_2=1$로 설정하는 것이 optimal 이다. 각 depot에 대해 비슷한 계산을 수행하면 IP($u$)의 optimal solution은 $y_1=y_3=y_5=0$, $y_2=x_{22}=x_{52}=1$, $y_4 = x_{64}=1$로 세팅하면 $z(u) = 3+1+\sum_{i \in M} u_i = 29$ 이다. 

&lt;br /&gt;&lt;br /&gt;


&lt;br /&gt;&lt;br /&gt;


&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 15 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/IP/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/IP/</guid>
        
        
        <category>최적화</category>
        
      </item>
    
      <item>
        <title>논문리뷰 - Coordinated logistics with a truck and a drone</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Abstract &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
We determine the efficiency of a delivery system in which an unmanned aerial vehicle (UAV), or a fleet of UAVs, provides service to customers while making return trips to a truck that is itself moving. In other words, a UAV picks up a package from the truck (which continues on its route), and after delivering the package, the UAV returns to the truck to pick up the next package. Although the hardware for such systems already exists, it is not yet understood to what extent such an approach can actually provide a significantly improved quality of service. By combining a theoretical analysis in the Euclidean plane with real-time numerical simulations on a road network, we conclude that the improvement in efficiency due to introducing a UAV is proportional to the square root of the ratio of the speeds of the truck and the UAV.&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Summary
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

이 논문은 드론과 같은 무인항공기와 트럭을 함께 사용하는 배달 시스템의 효율성을 판단한다. 유클리드 평면의 이론적 분석과 도로망에서의 실시간 시뮬레이션을 결합하여 무인항공기 도입에 따른 효율 향상은 트럭과 무인항공기의 속도 비율의 제곱근에 비례한다는 것이 결론이다. 

&lt;/div&gt;

&lt;hr /&gt;

&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;본문 내용
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify;  &quot;&gt;

최근 교통과 물류에서 가장 많이 언급되는 것 중 하나가 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;드론의 잠재적인 사용&lt;/b&gt;에 관한 것이다. 특히 배송 시스템에 드론을 많이 활용하고자 하는데 아마존의 Amazon Prime Air, 구글의 Project Wing, DHL의 Parcelcopter 등을 예시로 들 수 있다. 
&lt;br /&gt;&lt;br /&gt;

&lt;/div&gt;

&lt;div style=&quot;border:0px solid red; float: left; width:30%; box-sizing : border-box;  margin-left: 1em;&quot;&gt; &lt;img src=&quot;/images/post_img/amazon_prime_air.jpg&quot; width=&quot;230&quot; height=&quot;150&quot; /&gt; &lt;p align=&quot;center&quot;&gt;Amazon Prime Air&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;border:0px solid green; float: left; margin-left:2.5%; margin-right: 2%; width:30%; box-sizing : border-box&quot;&gt; &lt;img src=&quot;/images/post_img/Google-Project-Wing.jpg&quot; width=&quot;230&quot; height=&quot;150&quot; /&gt;&lt;p align=&quot;center&quot;&gt;Project Wing&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;border:0px solid blue; float: right; width:30%; box-sizing : border-box; margin-right: 1em;&quot;&gt; &lt;img src=&quot;/images/post_img/parcel.jpg&quot; width=&quot;230&quot; height=&quot;150&quot; /&gt;&lt;p align=&quot;center&quot;&gt;Parcelcopter&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; &quot;&gt;

여기서 last-mile delivery의 수요가 증가할 것이라는 언급이 있다. 라스트 마일이란 상품이 최종 목적지까지 배송되기 위한 과정으로 상품을 개인 소비자에게 직접 전달하기 위한 배송 마지막 구간을 의미한다. 즉, 무인정찰기를 배송시스템에 도입하여 하늘과 도로를 통해 배송함으로써 차세대 물류 시스템을 수행할 것이라는 전망이다. 무인항공기 기반 배송 시스템은 장단점이 명백하게 있는데 일단 드론은 운송 비용이 낮고 사람의 개입없이 운행할 수 있으며 도로 교통에 영향을 받지 않기 때문에 빠르게 운행할 수 있다. 그러나 운반 용량이 매우 작고 이동 반경이 짧으며 충전을 자주 해야한다. 

&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig1.png&quot; width=&quot;600&quot; height=&quot;300&quot; /&gt;
&lt;/p&gt;
위의 그림은 트럭으로만 배달한 경우, 드론으로만 배달한 경우, 트럭과 드론으로 배달한 경우의 배송경로를 나타낸다. 드론은 트럭의 속도보다 약 4배 정도 빠르다고 가정하였고 (c)에서 볼 수 있듯이 어느 한 가지로 배송하는 것과는 배송 경로의 차이가 있음을 알 수 있다. 
&lt;br /&gt;&lt;br /&gt;

이 논문의 목적은 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;드론과 트럭을 함께 사용하여 배송하는 것의 효율성을 판단&lt;/b&gt;하는 것이다. 이러한 실제 시스템 중 하나가 HorseFly이다. 실제로 어느 정도까지 서비스 품질을 향상시킬 수 있는지 파악되지 않았기 때문에 수학적으로 얼마나 개선을 실현시킬 수 있는지 언급한다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/horsefly.png&quot; width=&quot;450&quot; height=&quot;280&quot; /&gt;
&lt;/p&gt;
이는 TSP의 일반적인 경우이므로 최적으로 풀기 매우 어렵다. 그러므로 문제를 작은 파라미터 집합으로 줄이고 이러한 파라미터가 문제의 결과에 어떻게 영향을 미치는지 결정한다. 고객은 유클리드 평면에서 확률 밀도에 따라 분포한다고 가정한다. 이 논문은 특정 문제 사례에 대한 것보다는 인구 밀도에 따라 한 지역에서 많은 고객이 서비스를 받을 때 장기적인 행동에 대해 신경을 쓴다. 본질적으로 VRP 모델의 사례로 생각할 수 있다. &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;서로 정반대되는 장단점을 가진 두 종류의 차량을 최적으로 조정하는 문제&lt;/b&gt;로 생각할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
$n$개의 고객이 있다고 가정하며 트럭의 속도는 $\phi_0$, 드론의 속도는 $\phi_1$로 나타낸다. ($\phi_0&amp;lt;\phi_1$) compact planar region을 $\mathcal{R}$, $\mathcal{R}$에서의 loop를 $\mathcal{L}$, 모든 loop $\mathcal{L}$의 집합을 Loop($\mathcal{R}$)이라 하면 $d(x, \mathcal{L})$를 다음과 같이 $x$와 loop $\mathcal{L}$ 사이의 거리로 나타낼 수 있다. 
$$
d(x, \mathcal{L})=\min _{x^{\prime} \in \mathcal{L}}\left\|x-x^{\prime}\right\|
$$
이는 일반적인 유클리드 거리를 나타내고 {1,...$n$}의 순열 집합을 $S_n (\sigma \in S_n)$이라 하면 항공기에서 집합 $S$의 $\epsilon$-neighborhood는 다음과 같이 $N_{\epsilon}(\mathcal{S})$로 쓰인다. 
$$
N_{\epsilon}(\mathcal{S})=\left\{x \in \mathbb{R}^{2}: \min _{x^{\prime} \in \mathcal{S}}\left\|x-x^{\prime}\right\| \leq \epsilon\right\}
$$
먼저 앞서 언급한 &lt;i&gt;horsefly routing problem&lt;/i&gt;을 공식적으로 정의한다. 트럭 1대와 드론 1대에 대해 $p_1,...,p_n$을 포인트의 집합이라 한다면 다음을 만족하는 최적 솔루션이 $p_1,...,p_n$의 최적 &lt;i&gt;horsefly tour&lt;/i&gt;이다. 

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/eq1.png&quot; width=&quot;550&quot; height=&quot;60&quot; /&gt;
&lt;/p&gt;

아래 그림은 $p_1,...p_6$의 지점에 대해 $\phi_1/\phi_0=3/2$ 인 문제와 $\phi_1/\phi_0=3$인 문제의 horsefly 경로 문제의 솔루션이다. $x_1$을 임의의 출발점으로 정의하면, 두 경로 모두 $\sigma = {1,3,5,2,6,4}$이다. 
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig2.png&quot; width=&quot;550&quot; height=&quot;260&quot; /&gt;
&lt;/p&gt;
$\mathcal{L}$의 $\epsilon$-neighborhood는 Route의 내부(inner) 부분인 $R_{\text{in}}$와  외부(outer) 부분인 $R_{\text{out}}$을 가진다. 아래 그림의 (a)는 $R_{\text{in}}$과 $R_{\text{out}}$을 나타낸다. 색칠된 부분과 빗금친 부분이 모두 $R_{\text{out}}$이므로 면적 Area($R_{\text{out}}$) = $\pi \epsilon^{2}+\epsilon \ell$, 둘레  perimeter($R_{\text{out}}$) = $\ell + 2\pi\epsilon$이다. (b)는 내부 loop $\mathcal{L}_\epsilon^{\prime}$ 과 모든 $\epsilon^{\prime}$에 대해 $R_{\mathrm{out}}^{\prime} \subseteq R_{\mathrm{in}}$ 임을 보여준다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig3.png&quot; width=&quot;550&quot; height=&quot;260&quot; /&gt;
&lt;/p&gt;
아래 그림의 (a)와 (b)는 loop $\mathcal{L}$을 가지는 지역 $\mathcal{R}$을 통과하는 지그재그(zig-zagging) 모양과 나선형(spiralling)모양의 투어를 나타낸다. 수요 밀도가 불균등(non-uniform)일 때, (c)와 (d)에서 같이 최적 loop는 밀도가 더 높은 지역에 집중되어야 한다.  
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig4.png&quot; width=&quot;650&quot; height=&quot;200&quot; /&gt;
&lt;/p&gt;
아래 그림에는 $N$=16인 사각형 패치 $\mathcal{P}_i$가 있다. (a)와 (b)는 하나의 loop를 패치의 모양에만 의존하는 방식으로 항상 다수의 loop로 분해할 수 있음을 보여준다. (c)와 (d) 또한, 패치의 모양에만 의존하는 방식으로 하나의 loop로 loop들의 집합을 항상 결합할 수 있음을 보여준다.

&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig5.png&quot; width=&quot;650&quot; height=&quot;200&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
[참고] &lt;i&gt;Claim&lt;/i&gt;9. 위의 식 (1)의 lower bound가 문제의 최적 목적 값이다. 
&lt;img src=&quot;/images/post_img/eq2.png&quot; width=&quot;500&quot; height=&quot;60&quot; /&gt;
&lt;/p&gt;
아래 그림은 &lt;i&gt;Claim&lt;/i&gt;9의 스케치이다. (a)와 같이 문제(1)의 솔루션에서 시작하고 (b)와 같이 $x_i^{\prime}$이 구성된다. 그리고 나서 (c)처럼 $x_i^{\prime}$들을 통해 투어를 얻는다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig6.png&quot; width=&quot;650&quot; height=&quot;200&quot; /&gt;
&lt;/p&gt;
이 논문에서는 2가지 계산 실험을 하는데 첫 번째 실험은 계수 $\alpha$(논문의 (12)와 (???)에서 사용됨)를 추정하기 위해 사용하는 균일하게 분포된 수요를 가지는 unit square에서 이루어진다. 두 번째 실험에서는 $\alpha$의 추정치를 사용하여 균일하지 않은 분포에 따른 수요와 도로망에서의 실시간 주행 정보가 사용될 때의 효율성 향상에 대해 예측을 한다. 아래 그림은 두 개의 다른 horsefly 투어를 나타낸다. (a)는 $k$=1, $\phi_1$=1.5이고 (b)는 $k$=3, $\phi_1$=3이다. (여기서 $k$는 무인항공기의 개수이다.) $p_i$의 다른 색깔 (검정, 회색, 흰색)은 3개의 무인항공기 중 어느 것이 해당 지역을 방문하는지를 나타낸다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig7.png&quot; width=&quot;550&quot; height=&quot;280&quot; /&gt;
&lt;/p&gt;
아래 그림에서 (a)는 캘리포니아(California) 주 패서디나(Pasadena)의 지도를 보여주고 (b)는 패서디나에 위치한 모든 1734 인구조사(census) 블록의 중심으로 구성된 초기 데이터 집합을 보여준다. (c)는 그 중심에서 샘플링한 $n$=25인 지점의 도로망에 대한 TSP 투어를 나타내고 (d)는 2단계 휴리스틱(논문 4.1참고)을 사용하여 계산한 horsefly tour를 보여준다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig8.png&quot; width=&quot;750&quot; height=&quot;400&quot; /&gt;
&lt;/p&gt;
아래 12개 차트는 각각 특정한 수의 고객 $n$과 무인항공기 속도 $\phi_1$에 대해 수행한 실험이다. 
검은색 막대는 트럭 한 대가 $n$개의 고객을 방문하는 데 걸리는 시간(시간)을 나타낸다. 회색 막대는 트럭과 무인항공기가 horsefly 투어를 할 것으로 예상되는 시간을 나타낸다. 흰색 바는 트럭과 무인정찰기가 horsefly 투어를 수행하는 데 소요되는 실제 시간을 나타낸다.

&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig9.png&quot; width=&quot;750&quot; height=&quot;400&quot; /&gt;
&lt;/p&gt;
아래 차트는 무인항공기 개수 $k$와 속도 $\phi_1$에 대해 수행한 실험이다. 
&lt;br /&gt;&lt;br /&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/fig10.png&quot; width=&quot;750&quot; height=&quot;400&quot; /&gt;
&lt;/p&gt;
실험 결과 트럭만 사용하는 것보다 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;트럭과 무인항공기를 동시에 사용했을 때 시간이 더 적게 걸리는 것&lt;/b&gt;을 확인할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
논문 결과는 다음과 같이 정리할 수 있다. 
&lt;ul&gt;

&lt;li&gt;무인항공기와 트럭 배달의 효율성은 각각의 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;속도 비율의 제곱근에 비례&lt;/b&gt;한다.&lt;/li&gt;
&lt;li&gt;True globally 최적 솔루션이 아니라 트럭과 무인항공기 사이의 조정된 경로를 계산하기 위해 &lt;b style=&quot;color:#d7385e; font-size:1.2&quot;&gt;휴리스틱한 방법&lt;/b&gt;을 사용함.(분석의 weak point 중 하나)&lt;/li&gt;
&lt;li&gt;이 논문에서 제시된 문제에 대한 솔루션을 찾는 테크닉을 현재까지 알지 못하지만, 물류에 대한 무인항공기의 관심이 증가함에 따라 향후 몇 년 내에 그러한 기술들이 가능할 것으로 예상함.&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;hr /&gt;


&lt;div style=&quot;font-weight:700; font-size:1.3em; text-align:center;&quot;&gt;Cite
&lt;/div&gt;
&lt;br /&gt;
&lt;span style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; text-indent:0%; font-family: Times New Roman; &quot;&gt;
Carlsson, J. G., &amp;amp; Song, S. (2018). Coordinated logistics with a truck and a drone. &lt;i&gt;Management Science, 64&lt;/i&gt;(9), 4052-4069.
&lt;/span&gt;
&lt;span style=&quot;font-weight:400; font-size:1.0em;&quot;&gt;
&lt;a href=&quot;https://pdfs.semanticscholar.org/23a4/3524fd5168acfd589e919c143f49a6eeeac3.pdf&quot;&gt; 논문 링크 &lt;/a&gt;
&lt;/span&gt;

&lt;!-- &lt;span style=&quot;background-color: #f3c623&quot;&gt; --&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 13 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/%EB%85%BC%EB%AC%B8%20%EB%A6%AC%EB%B7%B02/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/%EB%85%BC%EB%AC%B8%20%EB%A6%AC%EB%B7%B02/</guid>
        
        
        <category>논문리뷰</category>
        
      </item>
    
      <item>
        <title>인공신경망 - Recommender Systems</title>
        <description>&lt;hr /&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
정보 기술 분야에서 머신러닝의 주요한 응용분야 중 하나는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;잠재 고객에게 아이템을 추천하는 것&lt;/b&gt;이다. 이를 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;온라인 광고&lt;/b&gt;와 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;아이템 추천&lt;/b&gt; 두 가지 타입으로 구분할 수 있다. 둘 다 사용자와 아이템 간의 연관성을 예측하는데 의존하며, 광고가 표시되거나 해당 아이템에 대한 추천이 사용자에게 제시될 경우 어떤 행동의 확률이나 기대되는 이득을 예측한다. 때떄로, 추천은 제품을 실제로 팔기 위한 목적이 아닌 소셜 네트워크 뉴스 피드에 표시할 게시물을 선택하거나 영화 추천, 농담 추천, 전문가의 조언 추천, 비디오 게임 플레이어 매칭, 데이트 서비스 매칭 등에 관한 것일 수 있다. 
&lt;br /&gt;&lt;br /&gt;
이것과 연관된 문제는 감독(supercised)학습 문제처럼 처리된다. 아이템과 사용자에 대한 정보가 주어지면 관심의 프록시(proxy)를 예측하기 때문이다. 이는 종종 회귀분석(조건부 기댓값을 예측) 또는 확률적 분류 문제(discrete한 사건의 조건부 확률을 예측)로 해결한다. 추천자 시스템에 대한 초기 작업은 이러한 예측을 위해 사용자 ID와 아이템 ID 같은 최소한의 인풋 정보에 의존했다. 이런 맥락에서 일반화하는 유일한 방법은 다른 사용자나 다른 아이템에 대한 타겟 변수값의 패턴간 유사성에 의존하는 것이다. 
&lt;br /&gt;&lt;br /&gt;
이 원리에 기초한 알고리즘이 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;collaborate filtering&lt;/b&gt; 이다. 비모수적 접근법과 모수적 방법 모두 가능하다. 모수적 방법은 각 사용자와 아이템에 대한 분포적인 표현(임베딩(embedding)으로 불린다.)을 학습하는데 의존한다. 예측은 다음과 같이 사용자 임베딩과 아이템 임베딩 (사용자 ID나 아이템 ID 중 하나에 의존하는 상수에 의해 수정될 가능성이 있다.) 사이의 내적을 통해 구한다. 

$$
\hat{R}_{u, i}=b_{u}+c_{i}+\sum_{j} A_{u, j} B_{j, i}
$$

Collaboratice filtering 시스템은 기본적인 제한이 있다. 새로운 아이템이나 사용자가 도입되면, 기록이 없기 때문에 다른 아이템이나 사용자와의 유사성 또는 새로운 사용자와 기존 아이템 사이의 연관성의 정도를 평가할 방법이 없다는 것이다. 이를 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;cold-start &lt;/b&gt;recommendations 문제라고 부른다. 콜드 스타트 추천 문제를 해결하는 일반적인 방법은 개별적인 사용자와 아이템에 대해 추가적인 정보를 도입하는 것이다. 예를 들어 추가적인 정보는 사용자 프로필 정보나 각 아이템의 특징이 될 수 있다. 이와 같은 정보를 사용하는 시스템을 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;content-based recommender&lt;/b&gt; 시스템이라고 한다. 풍부한 사용자 특징이나 아이템 특징의 집합에서 임베딩으로 매핑(mapping)하는 것은 딥러닝 구조(architecture)를 통해 학습될 수 있다. 
&lt;/div&gt;
</description>
        <pubDate>Sun, 12 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ANN10/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ANN10/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>인공신경망 - Challenge of Long-Term Dependencies</title>
        <description>&lt;hr /&gt;
&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

순환(recurrent) 네트워크에서 long-term dependencies를 학습하는 기본적인 문제는 여러 단계에 걸쳐 전파되는 기울기가 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;사라지거나(vanish)) 폭발하는(explode)&lt;/b&gt; 경향이 있다는 것이다. 대부분의 경우 vanish 문제이고 explode 문제는 드물지만 최적화에 더 어려움을 준다. 순환 관계를 다음과 같이 비선형 활성화 함수와 인풋 $x$가 없는 매우 단순한 순환 신경망으로 생각할 수 있다. 

$$
\boldsymbol{h}^{(t)}=\boldsymbol{W}^{\top} \boldsymbol{h}^{(t-1)}
$$

이를 다음과 같이 단순화할 수 있다. 

$$
\boldsymbol{h}^{(t)}=\boldsymbol{(W^t)}^{\top} \boldsymbol{h}^{(0)}
$$

만약 $\boldsymbol{W}$가 eigendecomposition이면 순환성(recurrence)은 더 단순화될 수 있다.

$$
\boldsymbol{h}^{(t)}=\boldsymbol{Q}^{\top} \Lambda^t \boldsymbol{Q} \boldsymbol{h}^{(0)}
$$

고유값이 $t$승으로 상승하는 것은 크기(magnitude)가 1보다 작은 고유값은 0으로 감소하고 1보다 큰 고유값은 explode되도록 유발한다. 가장 큰 고유벡터로 정렬되지 않은 $\boldsymbol{h}^{(0)}$의 성분은 결국에는 버려질 것이다. 
&lt;br /&gt;&lt;br /&gt;

만약 각 time step마다 가중치가 다른 $w^{(t)}$를 가지는 비순환적 네트워크를 만들면 상황이 달라진다. 초기 상태가 1로 주어진다면, 시간 $t$에서 상태는 $\prod_{t}w^{(t)}$로 주어진다. 평균이 0이고 분산이 $v$값을 가지는 서로 독립인 $w^{(t)}$값이 랜덤하게 생성된다고 가정하면 산출물(product)의 분산은 $O(v^n)$이다. 원하는 분산 $v^*$를 얻기 위해 분산 $v=\sqrt[n]{v^*}$를 가지는 개별적인 가중치를 선택할 수 있다. 따라서 신중하게 선택한 스케일링을 가지는 매우 깊은 feedforward networks는 vanishing 과 exploding gradient problem을 피할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
모델이 long-term dependencies가 나타날 수 있을 때마다 long-term interaction의 기울기는 short-term interaction의 기울기보다 기하급수적으로 더 작은 크기를 가진다. 이러한 의존성 대한 신호는 short-term dependencies에서 발생하는 가장 작은 변동(fluctuations)에 의해 숨겨지는 경향이 있기 때문에 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;long-term dependencies를 학습하는데 오랜 시간이 걸릴 수 있다.&lt;/b&gt; 
&lt;br /&gt;&lt;br /&gt;
포착해야하는 의존성의 범위가 증가함에 따라 gradient-based optimization은 점점 어려워진다. SGD를 통한 전통적인 RNN의 성공적인 트레이닝 확률이 연속적인 길이가 길어지면 (10 또는 20 등) 0에 빠르게 도달하기 때문이다. 
&lt;/div&gt;
</description>
        <pubDate>Sun, 12 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ANN09/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ANN09/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>인공신경망 - Motivation</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;

Convolution은 머신러닝 시스템을 향상시킬 수 있는 세 가지 중요한 아이디어를 활용한다. 각각은 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;sparse interactions&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;parameter sharing&lt;/b&gt;, &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;equivariant representations&lt;/b&gt; 이다. 컨볼루션 네트워크는 주로 sparse interaction을 가진다. sparse interaction은 sparse connectivity 또는 sparse weights라고도 한다. 이것은 커널(kernel)을 인풋보다 작게 함으로써 이루어진다. 즉, 더 적은 파라미터를 저장해야한다는 의미이다. 또한, 아웃풋을 계산하기위해 더 적은 작업(operations)이 요구된다는 것이다. 
&lt;br /&gt;&lt;br /&gt;

&lt;div style=&quot;border: 1px; float: right;margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/AN13.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;div style=&quot;border: 1px; margin-left: 1em; margin-right: 1em; &quot;&gt;
&lt;img src=&quot;/images/post_img/AN12.png&quot; width=&quot;290&quot; height=&quot;300&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
아래 오른쪽의 이미지는 원본 사진의 각 픽셀을 취해 왼쪽의 인접 픽셀의 값을 빼면서 만들어졌다. 두 이미지 모두 280 픽셀이며 입력 이미지는 320 픽셀인 반면 출력 이미지는 319 픽셀이다. 이 변환은 두 개의 요소를 포함하는 컨볼루션 커널로 설명될 수 있고 319*280*3 = 267,960의 floating-point(부동 소수점, CPU의 성능을 수치로 나타낼 때 사용되는 단위) 연산이 요구된다. 행렬곱으로 동일한 변환을 설명하려면 320*280*319*280 또는 80억 이상의 entries가 필요하다. 
&lt;br /&gt;&lt;br /&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/AN14.png&quot; width=&quot;450&quot; height=&quot;280&quot; /&gt;
&lt;/div&gt;
&lt;br /&gt;
parameter sharing의 특정한 형태는 레이어가 해석(translation)에 동일성(equivariance)이라 불리는 특성을 갖도록 한다. 함수가 동일하다고 말하는 것은 입력이 바뀌면 출력이 같은 방식으로 바뀐다는 것을 의미한다. 구체적으로 함수 $f(x)$는 $f(g(x)) = g(f(x))$이라면 함수 $g$와 동일하다. convolution의 경우 만약 $g$가 인풋을 해석하는 어떤 함수라면 convolution 함수는 $g$와 동일해진다. 만약 인풋에 있는 객체를 움직이면, 인풋의 representation은 아웃풋에서 같은 양만큼 움직일 것이다. 그러나 Convolution은 이미지의 크기(scale) 변화나 회전 등의 변형과는 동일시 되지 않는다. 

&lt;/div&gt;
</description>
        <pubDate>Sun, 12 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ANN08/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ANN08/</guid>
        
        
        <category>수업</category>
        
      </item>
    
      <item>
        <title>인공신경망 - Basic Algorithms</title>
        <description>&lt;hr /&gt;

&lt;div style=&quot;font-weight:500; font-size:1.0em; margin-left: 1em; margin-right: 1em;text-align:justify; &quot;&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Stochastic Gradient Descent
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
Stochastic Gradient Descent(SGD)와 그 변형들은 머신러닝과 특히 딥러닝에서 가장 많이 사용된 최적화 알고리즘이다.
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/AN10.png&quot; width=&quot;580&quot; height=&quot;300&quot; /&gt;
&lt;/p&gt;

SGD 알고리즘의 가장 중요한 파라미터는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;learning rate&lt;/b&gt;이다. 실제로 시간이 지나면서 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;점차 learning rate를 줄일 필요&lt;/b&gt;가 있다. SGD 기울기 추정은 최소에 도달해도 사라지지(vanish) 않는 noise($m$개의 트레이닝 예제의 랜덤 샘플링)를 도입하기 때문이다. 실제로 흔히 반복(iteration) $\tau$ 까지 learning rate는 선형적으로 감소(decay)한다.
$$
\epsilon_{k}=(1-\alpha) \epsilon_{0}+\alpha \epsilon_{\tau}
$$
여기서 $\alpha=k/\tau$ 이고, 반복 $\tau$ 후 $\epsilon$은 상수로 남기는 것이 일반적이다. 
&lt;br /&gt;&lt;br /&gt;
learning rate는 시행착오(trial and error)를 통해 선택될 수 있지만 주로 시간의 함수로써 목적함수의 plot인 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;학습 곡선(curves)을 모니터링&lt;/b&gt;함으로써 선택하는 것이 가장 좋다. 선형 스케쥴을 사용할 때, 선택할 파라미터는 $\epsilon_{0}, \epsilon_{\tau}, \tau$ 이다. 일반적으로 $\tau$는 트레이닝 셋을 통해 수백번 통과하는데 필요한 반복 횟수로 설정되고 $\epsilon_{\tau}$는 $\epsilon_{0}$의 약 1%로 설정해야 한다. 
&lt;br /&gt;&lt;br /&gt;
그렇다면 $\epsilon_{0}$(초기 learning rate)은 어떻게 설정해야할까? 값이 너무 크면 학습 곡선이 격렬한(violent) 움직임(oscillations)을 보이고 비용 함수는 상당히 증가할 것이다. 반면 learning rate가 너무 낮으면 학습이 느리게 진행되고 초기 learning rate가 너무 낮으면 학습이 높은 비용값에 머무른다. 일반적으로 최적의 초기 learning rate는 처음 100번 정도 반복 후 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;가장 좋은 값을 내는 learning rate 보다는 높다.&lt;/b&gt; 그러므로 처음 몇 번의 반복을 모니터링하여 가장 좋은 learning rate보다 높은 값을 사용하지만 너무 높은 값은 심한 불안정을 초래하므로 적당한 값을 사용해야한다.  
&lt;br /&gt;&lt;br /&gt;
SGD와 관련된 미니배치 또는 online gradient-based optimization의 가장 중요한 특성은 업데이트당 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;계산 시간이 트레이닝 예제 수에 따라 증가하지 않는다&lt;/b&gt;는 것이다. 이는 심지어 트레이닝 예제의 수가 매우 커져도 수렴할 수 있음을 시사한다. 충분히 큰 데이터셋의 경우, SGD는 전체 트레이닝 셋을 처리하기 전에 마지막 테스트셋 에러의 일정한 허용오차(tolerance)이내로 수렴할 것이다. 
&lt;br /&gt;&lt;br /&gt;
SGD가 convex 문제에 적용될 때, 초과(excess) 에러는 $k$번 반복 후 $O(1/\sqrt{k})$ 이고, strongly convex인 경우 $O(1/k)$이다. Batch gradient descent는 이론상 SGD보다 수렴률이 더 높다. 그러나 $\text { Cramér-Rao }$는 일반화 에러가 $O(1/k)$보다 빨리 감소할 수 없다고 주장하고 있다. 큰 데이터셋을 가지는 SGD는 매우 적은 예제에 대해 기울기를 평가하면서 빠르게 초기 진행이 이루어지는 능력은 그것의 slow 수렴근사보다 더 크다. 학습과정동안 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;미니배치 사이즈를 점점 증가시킴으로써&lt;/b&gt; 배치와 SGD의 이점을 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;trade off&lt;/b&gt; 할 수 있다. 
&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Momentum
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;
SGD가 유명한 최적화 방법으로 남아있지만 이를 통한 학습은 간혹 느리게 진행될 수 있다. momentum 방법(Polyak,1964)은 특히 높은 곡률(curvature), 작지만 일정한 기울기 또는 noisy 기울기를 갖는 학습을 가속화하기 위해 설계되었다. 모멘텀 알고리즘은 이전 기울기들이 기하급수적으로 감소하는 이동 평균을 누적하여 그 방향으로 계속 움직인다. 
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/images/post_img/AN11.png&quot; width=&quot;350&quot; height=&quot;320&quot; /&gt;
&lt;/p&gt;
모멘텀 알고리즘은 변수 $v$를 속도(velocity) 역할로 도입한다. 속도는 음의 기울기가 기하급수적으로 감소하는 평균으로 설정된다. 물리학에서 모멘텀은 질량 시간 속도이다. 모멘텀 학습 알고리즘에서 단위 질량을 가정하므로 속도 벡터 $v$도 입자의 모멘텀으로 간주될 수 있다. 업데이트 룰은 다음과 같다. 

$$
\begin{array}{l}\boldsymbol{v} \leftarrow \alpha \boldsymbol{v}-\epsilon \nabla_{\boldsymbol{\theta}}\left(\frac{1}{m} \sum_{i=1}^{m} L\left(\boldsymbol{f}\left(\boldsymbol{x}^{(i)} ; \boldsymbol{\theta}\right), \boldsymbol{y}^{(i)}\right)\right) \\ \boldsymbol{\theta} \leftarrow \boldsymbol{\theta}+\boldsymbol{v}\end{array}
$$

이제 step의 사이즈는 일련의 기울기가 얼마나 크고 얼마나 정렬되었는지에 따라 달라진다. 스텝 사이즈는 연속적인 기울기 포인트가 정확하게 같은 방향일 때 가장 크다. 만약 모멘텀 알고리즘이 항상 기울기 $g$를 관찰한다면 최종(terminal) 속도에 도달할 때까지 $-g$ 방향으로 가속화될 것이다. 각 스텝의 사이즈는 다음과 같다.  

$$
\frac{\epsilon\|\boldsymbol{g}\|}{1-\alpha}
$$

흔히 실제 사용되는 $\alpha$의 값은 0.5, 0.9, 0.99이다. learning rate와 마찬가지로 $\alpha$도 시간이 지남에 따라 맞춰진다. 

&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight:700; font-size:1.3em;  margin-right: 1em;&quot;&gt;
Nesterov Momentum
&lt;/span&gt;
&lt;br /&gt;&lt;br /&gt;

Sutskever et al.(2013)은 모멘텀 알고리즘의 변형을 다음과 같이 제안했다. 

$$
\begin{array}{l}\boldsymbol{v} \leftarrow \alpha \boldsymbol{v}-\epsilon \nabla_{\boldsymbol{\theta}}\left[\frac{1}{m} \sum_{i=1}^{m} L\left(\boldsymbol{f}\left(\boldsymbol{x}^{(i)} ; \boldsymbol{\theta}+\alpha \boldsymbol{v}\right), \boldsymbol{y}^{(i)}\right)\right] \\ \boldsymbol{\theta} \leftarrow \boldsymbol{\theta}+\boldsymbol{v}\end{array}
$$

Nesterov 모멘텀과 표준 모멘텀의 차이는 &lt;b style=&quot;color:#d7385e;font-size:1.2&quot;&gt;어디서 기울기가 평가되는가&lt;/b&gt; 이다. Nesterov 모멘텀은 현재 속도가 적용된 후에 기울기가 평가된다. 따라서 Nesterov 모멘텀은 표준 모멘텀 방법에 보정(correction) 요소를 추가하려는 것으로 해석할 수 있다. convex batch gradient의 경우 Nesterov 모멘텀은 초과 에러의 수렴율을 $O(1/k)$ 에서 $O(1/k^2)$로 가져온다. 안타깝게도 SGD에서 Nesterov 모멘텀은 수렴율을 향상시키지 않는다. 
&lt;/div&gt;
</description>
        <pubDate>Sun, 12 Apr 2020 18:00:08 +0000</pubDate>
        <link>http://munjeongkang.github.io/ANN07/</link>
        <guid isPermaLink="true">http://munjeongkang.github.io/ANN07/</guid>
        
        
        <category>수업</category>
        
      </item>
    
  </channel>
</rss>
